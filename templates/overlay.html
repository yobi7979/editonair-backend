<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }
        #overlay-container {
            position: fixed;
            top: 0;
            left: 0;
            width: {{ canvas_width }}px;
            height: {{ canvas_height }}px;
            pointer-events: none;
            background: transparent;
        }
        .overlay-object {
            position: absolute;
            pointer-events: none;
            transform-origin: center center;
            --target-opacity: 1;
        }
        
        /* íšŒì „ëœ ê°ì²´ë¥¼ ìœ„í•œ ì¶”ê°€ ìŠ¤íƒ€ì¼ */
        .rotated-object {
            transform-origin: center center !important;
        }
        /* íš¨ê³¼ ì• ë‹ˆë©”ì´ì…˜ */
        .fadeIn {
            animation: fadeIn 1s ease-in;
        }
        .fadeOut {
            animation: fadeOut 1s ease-out;
        }
        .slideUpIn {
            animation: slideUpIn 1s ease-in;
        }
        .slideUpOut {
            animation: slideUpOut 1s ease-out;
        }
        .slideDownIn {
            animation: slideDownIn 1s ease-in;
        }
        .slideDownOut {
            animation: slideDownOut 1s ease-out;
        }
        .slideLeftIn {
            animation: slideLeftIn 1s ease-in;
        }
        .slideLeftOut {
            animation: slideLeftOut 1s ease-out;
        }
        .slideRightIn {
            animation: slideRightIn 1s ease-in;
        }
        .slideRightOut {
            animation: slideRightOut 1s ease-out;
        }
        .scaleIn {
            animation: scaleIn 1s ease-in;
        }
        .scaleOut {
            animation: scaleOut 1s ease-out;
        }
        .rotateIn {
            animation: rotateIn 1s ease-in;
        }
        .rotateOut {
            animation: rotateOut 1s ease-out;
        }
        .bounceIn {
            animation: bounceIn 1s cubic-bezier(0.36, 0, 0.66, -0.56);
        }
        .bounceOut {
            animation: bounceOut 1s cubic-bezier(0.36, 0, 0.66, -0.56);
        }
        .elasticIn {
            animation: elasticIn 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .elasticOut {
            animation: elasticOut 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .zoomIn {
            animation: zoomIn 1s ease-in;
        }
        .zoomOut {
            animation: zoomOut 1s ease-out;
        }
        /* ì»¤ë‹ ê°•ì œ ì ìš© */
        .overlay-object * {
            letter-spacing: 0px !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: var(--target-opacity, 1); }
        }
        @keyframes fadeOut {
            from { opacity: var(--target-opacity, 1); }
            to { opacity: 0; }
        }
        @keyframes slideUpIn {
            from { transform: translateY(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes slideUpOut {
            from { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: translateY(-100%) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes slideDownIn {
            from { transform: translateY(-100%) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes slideDownOut {
            from { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: translateY(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes slideLeftIn {
            from { transform: translateX(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: translateX(0) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes slideLeftOut {
            from { transform: translateX(0) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: translateX(-100%) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes slideRightIn {
            from { transform: translateX(-100%) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: translateX(0) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes slideRightOut {
            from { transform: translateX(0) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: translateX(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes scaleIn {
            from { transform: scale(0) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes scaleOut {
            from { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: scale(0) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes rotateIn {
            from { transform: rotate(calc(var(--rotation, 0deg) + 360deg)); opacity: 0; }
            to { transform: rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes rotateOut {
            from { transform: rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: rotate(calc(var(--rotation, 0deg) + 360deg)); opacity: 0; }
        }
        @keyframes bounceIn {
            0% { transform: translateY(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
            50% { transform: translateY(-20%) rotate(var(--rotation, 0deg)); opacity: 1; }
            70% { transform: translateY(10%) rotate(var(--rotation, 0deg)); opacity: 1; }
            85% { transform: translateY(-5%) rotate(var(--rotation, 0deg)); opacity: 1; }
            100% { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes bounceOut {
            0% { transform: translateY(0) rotate(var(--rotation, 0deg)); opacity: 1; }
            50% { transform: translateY(-20%) rotate(var(--rotation, 0deg)); opacity: 1; }
            70% { transform: translateY(10%) rotate(var(--rotation, 0deg)); opacity: 1; }
            85% { transform: translateY(-5%) rotate(var(--rotation, 0deg)); opacity: 1; }
            100% { transform: translateY(100%) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes elasticIn {
            0% { transform: scale(0.3) rotate(var(--rotation, 0deg)); opacity: 0; }
            50% { transform: scale(1.2) rotate(var(--rotation, 0deg)); opacity: 1; }
            70% { transform: scale(0.9) rotate(var(--rotation, 0deg)); opacity: 1; }
            85% { transform: scale(1.05) rotate(var(--rotation, 0deg)); opacity: 1; }
            100% { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes elasticOut {
            0% { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
            50% { transform: scale(1.2) rotate(var(--rotation, 0deg)); opacity: 1; }
            70% { transform: scale(0.9) rotate(var(--rotation, 0deg)); opacity: 1; }
            85% { transform: scale(1.05) rotate(var(--rotation, 0deg)); opacity: 1; }
            100% { transform: scale(0.3) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
        @keyframes zoomIn {
            from { transform: scale(0) rotate(var(--rotation, 0deg)); opacity: 0; }
            to { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
        }
        @keyframes zoomOut {
            from { transform: scale(1) rotate(var(--rotation, 0deg)); opacity: 1; }
            to { transform: scale(0) rotate(var(--rotation, 0deg)); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="overlay-container"></div>
    <script>
        // í”„ë¦¬ë¡œë”© ìºì‹œ
        let preloadCache = null;
        let isPreloading = false;
        
        // í”„ë¦¬ë¡œë”© í•¨ìˆ˜
        async function preloadProjectData(projectName) {
            if (isPreloading) return;
            isPreloading = true;
            
            try {
                console.log('í”„ë¦¬ë¡œë”© ì‹œì‘:', projectName);
                const response = await fetch(`/api/preload/${encodeURIComponent(projectName)}`);
                if (response.ok) {
                    preloadCache = await response.json();
                    console.log('í”„ë¦¬ë¡œë”© ì™„ë£Œ:', preloadCache);
                    
                    // ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ í”„ë¦¬ë¡œë”©
                    preloadImages(preloadCache);
                }
            } catch (error) {
                console.warn('í”„ë¦¬ë¡œë”© ì‹¤íŒ¨:', error);
            } finally {
                isPreloading = false;
            }
        }
        
        // ì´ë¯¸ì§€ ë¦¬ì†ŒìŠ¤ í”„ë¦¬ë¡œë”©
        function preloadImages(cache) {
            if (!cache.scenes) return;
            
            const imageUrls = new Set();
            cache.scenes.forEach(scene => {
                scene.objects.forEach(obj => {
                    if (obj.type === 'image' && obj.properties.src) {
                        imageUrls.add(obj.properties.src);
                    }
                });
            });
            
            console.log('ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì‹œì‘:', imageUrls.size, 'ê°œ');
            imageUrls.forEach(url => {
                const img = new Image();
                img.src = url;
            });
        }
        
        // ëª¨ì…˜ ê´€ë¦¬ í´ë˜ìŠ¤
        class MotionManager {
            constructor(container) {
                this.container = container;
                this.objects = new Map();
                this.currentScene = null;
            }

            // ì¸ëª¨ì…˜ ì ìš©
            applyInMotion(element, obj) {
                const motion = obj.in_motion || { type: 'none' };
                const style = this.getMotionStyle(motion, true);
                Object.assign(element.style, style);
                const className = `${motion.type === 'none' ? 'fade' : motion.type}In`;
                element.classList.add(className);
                return new Promise((resolve) => {
                    element.addEventListener('animationend', () => {
                        element.classList.remove(className);
                        element.style.animation = 'none';
                        
                        // íšŒì „ê°’ì„ CSS ë³€ìˆ˜ë¡œ ì„¤ì •í•˜ê³  ìµœì¢… ìƒíƒœ ì ìš©
                        if (obj.properties.rotation !== undefined && obj.properties.rotation !== null) {
                            element.style.setProperty('--rotation', `${obj.properties.rotation}deg`);
                            element.style.transform = `rotate(${obj.properties.rotation}deg)`;
                        } else {
                            element.style.setProperty('--rotation', '0deg');
                        }
                        
                        if (style.opacity) element.style.opacity = style.opacity;
                        element.dataset.inMotionCompleted = 'true';
                        this.checkAllInMotionsCompleted();
                        resolve();
                    }, { once: true });
                });
            }

            // ì•„ì›ƒëª¨ì…˜ ì ìš©
            applyOutMotion(element, obj) {
                const motion = obj.out_motion || { type: 'none' };
                const style = this.getMotionStyle(motion, false);
                Object.assign(element.style, style);
                const className = `${motion.type === 'none' ? 'fade' : motion.type}Out`;
                element.classList.add(className);
                return new Promise((resolve) => {
                    element.addEventListener('animationend', () => {
                        element.classList.remove(className);
                        element.style.animation = '';
                        element.style.animationDuration = '';
                        element.style.animationDelay = '';
                        element.style.animationFillMode = '';
                        element.style.animationTimingFunction = '';
                        element.style.display = 'none';
                        resolve();
                    }, { once: true });
                });
            }

            // ëª¨ë“  ì¸ëª¨ì…˜ ì™„ë£Œ í™•ì¸
            checkAllInMotionsCompleted() {
                const allElements = this.container.querySelectorAll('.overlay-object');
                const allCompleted = Array.from(allElements).every(el => el.dataset.inMotionCompleted === 'true');
                
                if (allCompleted) {
                    console.log('All in-motions completed, waiting for out-motion trigger...');
                }
            }

            // ëª¨ë“  ì•„ì›ƒëª¨ì…˜ ì™„ë£Œ ëŒ€ê¸°
            async waitForAllOutMotions() {
                const elements = this.container.querySelectorAll('.overlay-object');
                const outMotionPromises = [];
                
                console.log('Checking out motions for', elements.length, 'elements');
                console.log('Current scene:', this.currentScene);
                console.log('Current scene objects:', this.currentScene?.objects);

                elements.forEach(element => {
                    const objId = element.getAttribute('data-object-id');
                    console.log('Element objId:', objId);
                    console.log('Looking for object with ID:', objId);
                    console.log('Available object IDs:', this.currentScene?.objects?.map(o => o.id));
                    
                    const obj = this.currentScene.objects.find(o => o.id === parseInt(objId));
                    console.log('Found object:', obj);
                    
                    if (obj && obj.out_motion && obj.out_motion.type !== 'none') {
                        console.log('Applying out motion for object:', obj.id, 'type:', obj.out_motion.type);
                        outMotionPromises.push(this.applyOutMotion(element, obj));
                    } else {
                        console.log('No out motion for object:', objId, 'out_motion:', obj?.out_motion);
                        // ì•„ì›ƒëª¨ì…˜ì´ ì—†ëŠ” ê°ì²´ë„ display:none ì²˜ë¦¬
                        outMotionPromises.push(Promise.resolve().then(() => {
                            element.style.display = 'none';
                        }));
                    }
                });

                console.log('Total out motion promises:', outMotionPromises.length);

                if (outMotionPromises.length === 0) {
                    return true;
                }

                await Promise.all(outMotionPromises);
                // ëª¨ë“  ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•´ display:noneì„ í•œ ë²ˆ ë” ë³´ì¥ì ìœ¼ë¡œ ì²˜ë¦¬
                const allElements = this.container.querySelectorAll('.overlay-object');
                allElements.forEach(element => {
                    element.style.display = 'none';
                });
                return true;
            }

            // ëª¨ì…˜ ìŠ¤íƒ€ì¼ ê³„ì‚°
            getMotionStyle(motion, isIn) {
                // 'none'ë„ 2í”„ë ˆì„(0.033ì´ˆ)ì§œë¦¬ í˜ì´ë“œ íš¨ê³¼ë¡œ ì²˜ë¦¬
                let type = motion?.type || 'none';
                let duration = (type === 'none') ? 0.033 : (motion.duration || 1);
                let delay = motion.delay || 0;
                let easing = motion.easing || 'ease';
                let transform = '';
                let opacity = '';
                
                // íšŒì „ê°’ì„ í•­ìƒ í¬í•¨í•˜ëŠ” transform ìƒì„±
                const rotation = 'rotate(var(--rotation, 0deg))';
                
                switch (type) {
                    case 'none':
                    case 'fade':
                        opacity = isIn ? '1' : '0';
                        transform = rotation; // íšŒì „ê°’ë§Œ ì ìš©
                        break;
                    case 'slide_up':
                        transform = isIn ? `translateY(0) ${rotation}` : `translateY(100%) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_down':
                        transform = isIn ? `translateY(0) ${rotation}` : `translateY(-100%) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_left':
                        transform = isIn ? `translateX(0) ${rotation}` : `translateX(100%) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_right':
                        transform = isIn ? `translateX(0) ${rotation}` : `translateX(-100%) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'zoom_in':
                        transform = isIn ? `scale(1) ${rotation}` : `scale(0) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'zoom_out':
                        transform = isIn ? `scale(1) ${rotation}` : `scale(2) ${rotation}`;
                        opacity = isIn ? '0' : '1';
                        break;
                    default:
                        opacity = '';
                        transform = rotation; // ê¸°ë³¸ì ìœ¼ë¡œ íšŒì „ê°’ ì ìš©
                        break;
                }
                return {
                    animation: `${type === 'none' ? 'fade' : type}${isIn ? 'In' : 'Out'} ${duration}s ${easing} ${delay}s`,
                    animationFillMode: 'forwards',
                    animationTimingFunction: easing,
                    transform: transform,
                    opacity: opacity
                };
            }

            // ì”¬ ì—…ë°ì´íŠ¸
            updateScene(scene, skipInMotion = false) {
                this.currentScene = scene;
                this.container.innerHTML = '';
                this.objects.clear();
                
                [...(scene.objects || [])]
                  .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))
                  .forEach(obj => {
                    const element = createObjectElement(obj);
                    if (element) {
                        this.container.appendChild(element);
                        this.objects.set(obj.id, element);
                        if (!skipInMotion) {
                            // startTime, endTime ì ìš©
                            const timing = typeof obj.timing === 'string' ? JSON.parse(obj.timing) : (obj.timing || {});
                            const startTime = timing.startTime || 0;
                            const endTime = timing.endTime || (timing.duration || 5);

                            // ì¸ëª¨ì…˜ ì‹œì‘ ì „ì—ëŠ” ìˆ¨ê¹€
                            element.style.display = 'none';

                            // ì¸ëª¨ì…˜(ë“±ì¥)
                            setTimeout(() => {
                                element.style.display = 'block';
                                this.applyInMotion(element, obj);
                            }, startTime * 1000);

                            // ì•„ì›ƒëª¨ì…˜ì€ scene_out ì´ë²¤íŠ¸ì—ì„œë§Œ ì‹¤í–‰ë˜ë„ë¡ ì˜ˆì•½í•˜ì§€ ì•ŠìŒ
                            // (endTime ì •ë³´ëŠ” ì €ì¥í•´ë‘ê¸°ë§Œ í•¨)
                            element.dataset.endTime = endTime;
                        } else {
                            // ì¸ëª¨ì…˜ ìŠ¤í‚µ ì‹œ ìµœì¢… ìƒíƒœë¡œ ë°”ë¡œ ì„¤ì •
                            if (obj.in_motion && obj.in_motion.type !== 'none') {
                                const style = this.getMotionStyle(obj.in_motion, true);
                                if (style.transform) element.style.transform = style.transform;
                                if (style.opacity) element.style.opacity = style.opacity;
                            }
                            element.dataset.inMotionCompleted = 'true';
                        }
                    }
                  });
            }
        }

        // ì „ì—­ ë³€ìˆ˜ ë° ì´ˆê¸°í™”
        const socket = io({
            query: {
                project_id: {{ project.id }},
                user_id: {{ user_id }},
                channel_id: '{{ channel_id }}'
            }
        });
        const container = document.getElementById('overlay-container');
        const motionManager = new MotionManager(container);
        let currentScene = null; // ì´ˆê¸°ì—ëŠ” nullë¡œ ì„¤ì •
        let skipInMotion = sessionStorage.getItem('skipInMotion') === 'true';
        let isBroadcasting = true; // ê¸°ë³¸ì ìœ¼ë¡œ trueë¡œ ì„¤ì •

        // === WebSocket ì—°ê²° ìƒíƒœ ë””ë²„ê¹… ===
        console.log('ğŸ”Œ Initializing WebSocket connection...');
        console.log('Socket.IO version:', io.version);
        console.log('Project ID:', {{ project.id }});
        console.log('User ID:', {{ user_id }});
        
        // ì—°ê²° ìƒíƒœ ì²´í¬ í•¨ìˆ˜
        function checkConnectionStatus() {
            console.log('ğŸ“¡ WebSocket Status:');
            console.log('  - Connected:', socket.connected);
            console.log('  - Socket ID:', socket.id);
            console.log('  - Transport:', socket.io.engine?.transport?.name);
            console.log('  - Ready State:', socket.io.engine?.readyState);
            console.log('  - User Room: user_{{ user_id }}');
            return socket.connected;
        }

        // ì£¼ê¸°ì ìœ¼ë¡œ ì—°ê²° ìƒíƒœ ì²´í¬ (10ì´ˆë§ˆë‹¤)
        setInterval(checkConnectionStatus, 10000);

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸° ì”¬ ì„¤ì •
        const projectName = '{{ project.name }}';
        {% if scene %}
        const initialScene = {{ scene|tojson }};
        console.log('Initial scene data available:', initialScene);
        // ì´ˆê¸°ì—ëŠ” ì”¬ì„ ë Œë”ë§í•˜ì§€ ì•Šê³  ë°ì´í„°ë§Œ ì €ì¥
        // currentScene = initialScene; // ì£¼ì„ ì²˜ë¦¬
        // motionManager.updateScene(initialScene, false); // ì£¼ì„ ì²˜ë¦¬
        {% else %}
        console.log('No initial scene provided');
        {% endif %}

        // í”„ë¦¬ë¡œë”© ìƒíƒœ ì¶”ì 
        const preloadedImages = new Set();
        let isPreloadingComplete = false;
        let totalImagesToPreload = 0;
        
        // ì¦‰ì‹œ í”„ë¦¬ë¡œë”© í•¨ìˆ˜ (í˜ì´ì§€ ë¡œë“œì™€ ë™ì‹œì— ì‹œì‘)
        async function immediatePreloadAllImages() {
            console.log('ğŸš€ ì¦‰ì‹œ ëª¨ë“  ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì‹œì‘...');
            
            try {
                // í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ì”¬ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì˜¤ë²„ë ˆì´ìš© API ì‚¬ìš©)
                const username = '{{ username }}';
                const response = await fetch(`/api/overlay/users/${username}/projects/${projectName}`);
                const project = await response.json();
                
                if (!project.scenes) {
                    console.log('ğŸ“· í”„ë¦¬ë¡œë”©í•  ì”¬ì´ ì—†ìŒ');
                    isPreloadingComplete = true;
                    return;
                }
                
                // ëª¨ë“  ì´ë¯¸ì§€ URL ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±°)
                const allImageUrls = new Set();
                project.scenes.forEach(scene => {
                    const imageObjs = scene.objects.filter(obj => obj.type === 'image');
                    imageObjs.forEach(obj => {
                        if (obj.properties.src) {
                            allImageUrls.add(obj.properties.src);
                        }
                    });
                });
                
                if (allImageUrls.size === 0) {
                    console.log('ğŸ“· í”„ë¦¬ë¡œë”©í•  ì´ë¯¸ì§€ê°€ ì—†ìŒ');
                    isPreloadingComplete = true;
                    return;
                }
                
                totalImagesToPreload = allImageUrls.size;
                console.log(`ğŸ“· ì´ ${totalImagesToPreload}ê°œì˜ ê³ ìœ  ì´ë¯¸ì§€ ì¦‰ì‹œ í”„ë¦¬ë¡œë”© ì‹œì‘`);
                
                // ë³‘ë ¬ë¡œ í”„ë¦¬ë¡œë”© (ë¹ ë¥¸ ìºì‹±ì„ ìœ„í•´)
                const preloadPromises = Array.from(allImageUrls).map((imageUrl, index) => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        
                        const timeout = setTimeout(() => {
                            console.warn(`â° ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© íƒ€ì„ì•„ì›ƒ (${index + 1}/${totalImagesToPreload}): ${imageUrl}`);
                            resolve();
                        }, 3000); // ê°œë³„ ì´ë¯¸ì§€ë‹¹ 3ì´ˆ íƒ€ì„ì•„ì›ƒ
                        
                        img.onload = () => {
                            clearTimeout(timeout);
                            preloadedImages.add(imageUrl);
                            console.log(`âœ… ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì™„ë£Œ (${preloadedImages.size}/${totalImagesToPreload}): ${imageUrl}`);
                            resolve();
                        };
                        
                        img.onerror = () => {
                            clearTimeout(timeout);
                            console.warn(`âŒ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì‹¤íŒ¨ (${index + 1}/${totalImagesToPreload}): ${imageUrl}`);
                            resolve();
                        };
                        
                        img.src = imageUrl;
                    });
                });
                
                // ëª¨ë“  ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 10ì´ˆ)
                const allPreloadPromise = Promise.all(preloadPromises);
                const overallTimeout = new Promise(resolve => 
                    setTimeout(() => {
                        console.warn('â° ì „ì²´ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© íƒ€ì„ì•„ì›ƒ - 10ì´ˆ ê²½ê³¼');
                        resolve();
                    }, 10000)
                );
                
                await Promise.race([allPreloadPromise, overallTimeout]);
                
                isPreloadingComplete = true;
                console.log(`ğŸ¯ ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì™„ë£Œ: ${preloadedImages.size}/${totalImagesToPreload}ê°œ ì„±ê³µ`);
                
                // í”„ë¦¬ë¡œë”© ì™„ë£Œìœ¨ í‘œì‹œ
                const successRate = Math.round((preloadedImages.size / totalImagesToPreload) * 100);
                console.log(`ğŸ“Š í”„ë¦¬ë¡œë”© ì„±ê³µë¥ : ${successRate}%`);
                
            } catch (error) {
                console.error('âŒ ì¦‰ì‹œ í”„ë¦¬ë¡œë”© ì˜¤ë¥˜:', error);
                isPreloadingComplete = true;
            }
        }
        
        // ì´ë¯¸ì§€ê°€ ì´ë¯¸ ìºì‹œë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
        function isImageCached(imageUrl) {
            return preloadedImages.has(imageUrl);
        }

        // ì´ˆê¸°ì—ëŠ” ë”ë¯¸ ì”¬ìœ¼ë¡œ ì‹œì‘
        console.log('ğŸ”„ Loading initial dummy scene...');
        fetch('/api/dummy-scene')
            .then(response => response.json())
            .then(dummyScene => {
                console.log('ğŸ“¥ Initial dummy scene loaded:', dummyScene);
                currentScene = dummyScene;
                motionManager.updateScene(dummyScene, true); // skipInMotion = true
                console.log('âœ… Initial dummy scene applied - blank overlay ready');
                
                // ë”ë¯¸ ì”¬ ë¡œë”© ì™„ë£Œ í›„ ì¦‰ì‹œ ëª¨ë“  ì´ë¯¸ì§€ í”„ë¦¬ë¡œë”© ì‹œì‘
                immediatePreloadAllImages(); // ì¦‰ì‹œ ì‹œì‘
                
                // ë”ë¯¸ ì”¬ ë¡œë”© í›„ íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™”
                setTimeout(() => {
                    syncTimerStatesFromServer();
                }, 500);
            })
            .catch(error => {
                console.error('âŒ Error loading initial dummy scene:', error);
                // ë”ë¯¸ ì”¬ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ë¹ˆ ì”¬ ìƒì„±
                const emptyScene = {
                    id: 0,
                    name: 'Empty Scene',
                    objects: []
                };
                currentScene = emptyScene;
                motionManager.updateScene(emptyScene, true);
                console.log('âœ… Empty scene applied as fallback');
                
                // ì¦‰ì‹œ í”„ë¦¬ë¡œë”©ì€ ì—¬ì „íˆ ì‹œë„
                immediatePreloadAllImages();
            });

        // ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        socket.on('connect', () => {
            console.log('âœ… WebSocket connected successfully!');
            console.log('Socket ID:', socket.id);
            console.log('Transport:', socket.io.engine.transport.name);
            
            const userId = {{ user_id }};
            const channelId = '{{ channel_id }}';
            console.log('ğŸ  Joining user room: user_' + userId + ' (channel: ' + channelId + ')');
            
            // ì‚¬ìš©ìë³„ ë£¸ì— ì¡°ì¸
            const roomName = channelId && channelId !== 'default' ? 
                'user_' + userId + '_channel_' + channelId : 
                'user_' + userId;
            socket.emit('join', { room: roomName });
            console.log('ğŸ¯ Joined room: ' + roomName);
        });

        socket.on('disconnect', (reason) => {
            console.log('âŒ WebSocket disconnected:', reason);
            console.log('Will attempt to reconnect...');
        });

        socket.on('connect_error', (error) => {
            console.error('ğŸš« WebSocket connection error:', error);
        });

        socket.on('reconnect', (attemptNumber) => {
            console.log('ğŸ”„ WebSocket reconnected after', attemptNumber, 'attempts');
        });

        socket.on('reconnect_error', (error) => {
            console.error('ğŸ”„âŒ WebSocket reconnection error:', error);
        });

        // ë£¸ ì°¸ì—¬ ì™„ë£Œ ì´ë²¤íŠ¸
        socket.on('joined', (data) => {
            console.log('ğŸ¯ Joined room event received:', data);
            if (data.room) {
                console.log('âœ… Successfully joined room:', data.room);
            }
        });

        // ë°©ì†¡ ì‹œì‘ ì‹ í˜¸ê°€ ì˜¤ë©´ ê·¸ë•Œë¶€í„° ì”¬ ì ìš©
        socket.on('start_broadcast', () => {
            console.log('ğŸ“º Broadcast started');
            isBroadcasting = true;
            // í•„ìš”ì‹œ ì„œë²„ì— ì”¬ ë°ì´í„° ìš”ì²­
            socket.emit('request_scene');
        });

        // ì”¬ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ (ê¸°ì¡´ ì”¬ì˜ ê°ì²´ ë³€ê²½)
        socket.on('scene_update', (scene) => {
            console.log('ğŸ¬ Scene update event received:', scene);
            if (scene.id === currentScene?.id) {
                currentScene = scene;
                motionManager.updateScene(scene);
            }
        });

        // ê°ì²´ ì†ì„± ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        socket.on('object_live_update', (data) => {
            console.log('ğŸ¯ Object live update event received:', data);
            
            if (!currentScene) return;
            
            // í˜„ì¬ ì”¬ì˜ ê°ì²´ ëª©ë¡ì—ì„œ ì—…ë°ì´íŠ¸í•  ê°ì²´ ì°¾ê¸°
            const objIndex = currentScene.objects.findIndex(obj => obj.id === data.object_id);
            if (objIndex === -1) {
                console.warn(`âŒ ê°ì²´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: object_id=${data.object_id}`);
                return;
            }
            
            console.log(`âœ… ê°ì²´ ì°¾ìŒ: ${currentScene.objects[objIndex].name} (${currentScene.objects[objIndex].type})`);
            console.log(`ğŸ”„ ì†ì„± ì—…ë°ì´íŠ¸: ${data.property} = ${data.value}`);
            
            // ê°ì²´ ì†ì„± ì—…ë°ì´íŠ¸
            if (data.property === 'content') {
                // í…ìŠ¤íŠ¸ ê°ì²´ ë‚´ìš© ì—…ë°ì´íŠ¸
                currentScene.objects[objIndex].properties.content = data.value;
            } else if (data.property === 'src') {
                // ì´ë¯¸ì§€ ê°ì²´ src ì—…ë°ì´íŠ¸
                currentScene.objects[objIndex].properties.src = data.value;
            } else if (data.property === 'color') {
                // ë„í˜• ê°ì²´ ì»¬ëŸ¬ ì—…ë°ì´íŠ¸
                currentScene.objects[objIndex].properties.color = data.value;
            }
            
            // ê¸°ì¡´ ê°ì²´ ìš”ì†Œ ì—…ë°ì´íŠ¸ (ì œê±° í›„ ì¬ìƒì„± ëŒ€ì‹  ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸)
            const oldElement = motionManager.objects.get(data.object_id);
            if (oldElement) {
                // ê¸°ì¡´ ìš”ì†Œì˜ ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸
                if (data.property === 'content') {
                    // í…ìŠ¤íŠ¸ ë‚´ìš© ì—…ë°ì´íŠ¸ - SVG ë‚´ë¶€ì˜ text ìš”ì†Œ ì°¾ê¸°
                    const svgElement = oldElement.querySelector('svg');
                    if (svgElement) {
                        const textElement = svgElement.querySelector('text');
                        if (textElement) {
                            const oldText = textElement.textContent;
                            textElement.textContent = data.value;
                            console.log(`âœ… í…ìŠ¤íŠ¸ ë‚´ìš© ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${data.object_id} = ${oldText} â†’ ${data.value}`);
                        } else {
                            console.warn(`âŒ SVG ë‚´ í…ìŠ¤íŠ¸ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}`);
                        }
                    } else {
                        console.warn(`âŒ í…ìŠ¤íŠ¸ ê°ì²´ì˜ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}`);
                    }
                } else if (data.property === 'src') {
                    // ì´ë¯¸ì§€ src ì—…ë°ì´íŠ¸
                    const imgElement = oldElement.querySelector('img');
                    if (imgElement) {
                        const oldSrc = imgElement.src;
                        imgElement.src = data.value;
                        console.log(`âœ… ì´ë¯¸ì§€ src ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${data.object_id} = ${oldSrc} â†’ ${data.value}`);
                    } else {
                        console.warn(`âŒ ì´ë¯¸ì§€ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}`);
                    }
                } else if (data.property === 'color' || data.property === 'fill') {
                    // ë„í˜• ì»¬ëŸ¬ ì—…ë°ì´íŠ¸ - SVG ë‚´ë¶€ì˜ ë„í˜• ìš”ì†Œì˜ fill ì†ì„± ì—…ë°ì´íŠ¸
                    console.log(`ğŸ¨ ë„í˜• ì»¬ëŸ¬ ì—…ë°ì´íŠ¸ ì‹œì‘: ${data.object_id} = ${data.value}`);
                    
                    const svgElement = oldElement.querySelector('svg');
                    if (svgElement) {
                        const shapeElements = svgElement.querySelectorAll('polygon, ellipse, path, rect, circle');
                        console.log(`ğŸ” SVG ë‚´ ì°¾ì€ ë„í˜• ìš”ì†Œ: ${shapeElements.length}ê°œ`);
                        
                        if (shapeElements.length > 0) {
                            shapeElements.forEach((shapeElement, index) => {
                                const oldFill = shapeElement.getAttribute('fill');
                                shapeElement.setAttribute('fill', data.value);
                                console.log(`âœ… ë„í˜• ìš”ì†Œ ${index + 1} ì—…ë°ì´íŠ¸: ${oldFill} â†’ ${data.value}`);
                            });
                            console.log(`âœ… ë„í˜• ì»¬ëŸ¬ ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${data.object_id} = ${data.value} (${shapeElements.length}ê°œ ìš”ì†Œ)`);
                        } else {
                            console.warn(`âŒ SVG ë‚´ ë„í˜• ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}`);
                        }
                    } else {
                        console.warn(`âŒ ë„í˜• ê°ì²´ì˜ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}`);
                    }
                }
                console.log(`âœ… ê°ì²´ ë‚´ìš© ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${data.object_id}`);
            } else {
                // ê¸°ì¡´ ìš”ì†Œê°€ ì—†ìœ¼ë©´ í˜„ì¬ ì”¬ì„ ë‹¤ì‹œ ë Œë”ë§
                console.log(`âš ï¸ ê°ì²´ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${data.object_id}, ì”¬ ë‹¤ì‹œ ë Œë”ë§`);
                motionManager.updateScene(currentScene, true); // skipInMotion = trueë¡œ ë‹¤ì‹œ ë Œë”ë§
            }
        });

        // íƒ€ì´ë¨¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (í•˜ì´ë¸Œë¦¬ë“œ ë°©ì‹)
        socket.on('timer_update', (data) => {
            console.log('â° Timer event received:', data);
            
            if (!currentScene) return;
            
            if (data.action === 'start') {
                // íƒ€ì´ë¨¸ ì‹œì‘ - ë¡œì»¬ ê³„ì‚° ì‹œì‘
                console.log(`ğŸš€ íƒ€ì´ë¨¸ ì‹œì‘: ${data.object_id}`);
                startLocalTimer(data.object_id, data.start_time, data.elapsed, data.time_format);
            } else if (data.action === 'stop') {
                // íƒ€ì´ë¨¸ ì •ì§€ - ë¡œì»¬ ê³„ì‚° ì •ì§€
                console.log(`â¹ï¸ íƒ€ì´ë¨¸ ì •ì§€: ${data.object_id}`);
                stopLocalTimer(data.object_id, data.elapsed);
            } else if (data.action === 'reset') {
                // íƒ€ì´ë¨¸ ë¦¬ì…‹ - ë¡œì»¬ ê³„ì‚° ë¦¬ì…‹
                console.log(`ğŸ”„ íƒ€ì´ë¨¸ ë¦¬ì…‹: ${data.object_id}`);
                resetLocalTimer(data.object_id);
            } else if (data.action === 'sync') {
                // íƒ€ì´ë¨¸ ë™ê¸°í™” - ë“œë¦¬í”„íŠ¸ ë³´ì •
                console.log(`ğŸ”„ íƒ€ì´ë¨¸ ë™ê¸°í™”: ${data.object_id}`);
                syncLocalTimer(data.object_id, data.server_time, data.start_time, data.elapsed);
            }
        });



        // ì´ë¯¸ì§€ ë¡œë”© ì™„ë£Œ ëŒ€ê¸° í•¨ìˆ˜ (ìºì‹œ ìš°ì„  í™•ì¸)
        async function waitForSceneImagesReady(sceneData) {
            const imageObjects = sceneData.objects.filter(obj => obj.type === 'image');
            
            if (imageObjects.length === 0) {
                console.log('ğŸ“· ì”¬ì— ì´ë¯¸ì§€ê°€ ì—†ìŒ - ì¦‰ì‹œ ì§„í–‰');
                return;
            }
            
            console.log(`ğŸ“· ${imageObjects.length}ê°œ ì´ë¯¸ì§€ ì¤€ë¹„ ìƒíƒœ í™•ì¸`);
            
            // ì´ë¯¸ í”„ë¦¬ë¡œë”©ëœ ì´ë¯¸ì§€ë“¤ í•„í„°ë§
            const cachedImages = imageObjects.filter(obj => isImageCached(obj.properties.src));
            const uncachedImages = imageObjects.filter(obj => !isImageCached(obj.properties.src));
            
            console.log(`âœ… ì´ë¯¸ ìºì‹œëœ ì´ë¯¸ì§€: ${cachedImages.length}ê°œ`);
            console.log(`â³ ì•„ì§ ë¡œë”© í•„ìš”í•œ ì´ë¯¸ì§€: ${uncachedImages.length}ê°œ`);
            
            // ìºì‹œë˜ì§€ ì•Šì€ ì´ë¯¸ì§€ë“¤ë§Œ ë¡œë”© ëŒ€ê¸°
            if (uncachedImages.length === 0) {
                console.log('ğŸš€ ëª¨ë“  ì´ë¯¸ì§€ê°€ ì´ë¯¸ ìºì‹œë¨ - ì¦‰ì‹œ ì§„í–‰');
                return;
            }
            
            const imagePromises = uncachedImages.map((obj, index) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    const src = obj.properties.src;
                    
                    // í•œë²ˆ ë” ìºì‹œ í™•ì¸ (í”„ë¦¬ë¡œë”©ì´ ì™„ë£Œë˜ì—ˆì„ ìˆ˜ ìˆìŒ)
                    if (isImageCached(src)) {
                        console.log(`âœ… ì´ë¯¸ì§€ ìºì‹œ í™•ì¸ë¨: ${src}`);
                        resolve();
                        return;
                    }
                    
                    const timeout = setTimeout(() => {
                        console.warn(`â° ì´ë¯¸ì§€ ë¡œë”© íƒ€ì„ì•„ì›ƒ: ${src}`);
                        resolve(); // íƒ€ì„ì•„ì›ƒë˜ì–´ë„ ê³„ì† ì§„í–‰
                    }, 1000); // ìºì‹œë˜ì§€ ì•Šì€ ì´ë¯¸ì§€ëŠ” 1ì´ˆë§Œ ëŒ€ê¸° (ì´ë¯¸ ëŒ€ë¶€ë¶„ í”„ë¦¬ë¡œë”©ë¨)
                    
                    img.onload = () => {
                        clearTimeout(timeout);
                        console.log(`âœ… ì´ë¯¸ì§€ ë¡œë”© ì™„ë£Œ (${index + 1}/${uncachedImages.length}): ${src}`);
                        preloadedImages.add(src); // ìƒˆë¡œ ë¡œë”©ëœ ì´ë¯¸ì§€ë„ ìºì‹œì— ì¶”ê°€
                        resolve();
                    };
                    
                    img.onerror = () => {
                        clearTimeout(timeout);
                        console.warn(`âŒ ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨: ${src}`);
                        resolve(); // ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
                    };
                    
                    img.src = src;
                });
            });
            
            // ìºì‹œë˜ì§€ ì•Šì€ ì´ë¯¸ì§€ë“¤ ë¡œë”© ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 2ì´ˆ)
            const loadingPromise = Promise.all(imagePromises);
            const timeoutPromise = new Promise(resolve => 
                setTimeout(() => {
                    console.warn('â° ì”ì—¬ ì´ë¯¸ì§€ ë¡œë”© íƒ€ì„ì•„ì›ƒ - ê°•ì œ ì§„í–‰');
                    resolve();
                }, 2000)
            );
            
            await Promise.race([loadingPromise, timeoutPromise]);
            console.log('ğŸ¯ ëª¨ë“  ì´ë¯¸ì§€ ì¤€ë¹„ ì²˜ë¦¬ ì™„ë£Œ');
        }
        


        // ì”¬ ë³€ê²½ ì´ë²¤íŠ¸ ìˆ˜ì‹  (ê°œì„ ëœ ë²„ì „)
        socket.on('scene_change', async (data) => {
            console.log('ğŸ”„ Scene change event received:', data);
            console.log('ğŸŒ Loading scene from API:', data.scene_id);
            
            try {
                // 1ë‹¨ê³„: ìƒˆë¡œìš´ ì”¬ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch(`/api/overlay/scenes/${data.scene_id}`);
                const newScene = await response.json();
                console.log('ğŸ“¥ New scene loaded from API:', newScene);
                
                // 2ë‹¨ê³„: í•´ë‹¹ ì”¬ì˜ ëª¨ë“  ì´ë¯¸ì§€ ë¡œë”© ì™„ë£Œ ëŒ€ê¸° (ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì¡°ìš©íˆ ì²˜ë¦¬)
                await waitForSceneImagesReady(newScene);
                
                // 3ë‹¨ê³„: ë¡œë”© ì™„ë£Œ í›„ ì¸ëª¨ì…˜ ì‹œì‘
                console.log('ğŸš€ ì´ë¯¸ì§€ ì¤€ë¹„ ì™„ë£Œ - ì”¬ ì „í™˜ ì‹œì‘');
                
                currentScene = newScene;
                motionManager.updateScene(newScene, false); // ì´ì œ ì•ˆì „í•˜ê²Œ ì¸ëª¨ì…˜ ì‹¤í–‰
                console.log('âœ… ì”¬ ì „í™˜ ì™„ë£Œ');
                
                // ì”¬ ì „í™˜ í›„ íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™”
                setTimeout(() => {
                    syncTimerStatesFromServer();
                }, 500);
                
            } catch (error) {
                console.error('âŒ ì”¬ ë³€ê²½ ì¤‘ ì˜¤ë¥˜:', error);
                
                // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ê¸°ë³¸ì ì¸ ì”¬ ì „í™˜ì€ ì‹œë„
                try {
                    const response = await fetch(`/api/overlay/scenes/${data.scene_id}`);
                    const newScene = await response.json();
                    currentScene = newScene;
                    motionManager.updateScene(newScene, true); // skipInMotion = true
                    console.log('âš ï¸ ì˜¤ë¥˜ ë³µêµ¬ - ê¸°ë³¸ ì”¬ ì „í™˜ ì™„ë£Œ');
                } catch (fallbackError) {
                    console.error('ğŸ’¥ ì”¬ ì „í™˜ ì™„ì „ ì‹¤íŒ¨:', fallbackError);
                }
            }
        });

        // ì”¬ ì•„ì›ƒ ì´ë²¤íŠ¸ ìˆ˜ì‹ 
        socket.on('scene_out', async (data) => {
            console.log('ğŸ­ Scene out event received:', data);
            
            if (currentScene && currentScene.objects && currentScene.objects.length > 0) {
                console.log('ğŸ¬ Applying out motions to current scene objects...');
                
                try {
                    // ì•„ì›ƒ ëª¨ì…˜ ì‹¤í–‰ ë° ì™„ë£Œ ëŒ€ê¸°
                    await motionManager.waitForAllOutMotions();
                    console.log('âœ… All out motions completed');
                } catch (error) {
                    console.error('âŒ Error during out motions:', error);
                }
            }
            
            // ì•„ì›ƒ ëª¨ì…˜ ì™„ë£Œ í›„ ë”ë¯¸ ì”¬ìœ¼ë¡œ ì „í™˜
            console.log('ğŸ”„ Loading dummy scene after out motions...');
            
            try {
                const response = await fetch('/api/dummy-scene');
                const dummyScene = await response.json();
                console.log('ğŸ“¥ Dummy scene loaded:', dummyScene);
                
                currentScene = dummyScene;
                motionManager.updateScene(dummyScene, true);
                console.log('âœ… Dummy scene applied successfully');
            } catch (error) {
                console.error('âŒ Error loading dummy scene:', error);
            }
        });

        // ë¡œì»¬ íƒ€ì´ë¨¸ ê´€ë¦¬ (í•˜ì´ë¸Œë¦¬ë“œ ë°©ì‹)
        const localTimers = new Map();
        const timerIntervals = new Map();
        
        // ë¡œì»¬ íƒ€ì´ë¨¸ ì‹œì‘
        function startLocalTimer(objectId, serverStartTime, elapsed, timeFormat = 'MM:SS') {
            // ê¸°ì¡´ intervalì´ ìˆìœ¼ë©´ ì •ë¦¬ (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)
            const prevInterval = timerIntervals.get(objectId);
            if (prevInterval) {
                clearInterval(prevInterval);
                timerIntervals.delete(objectId);
                console.log(`ğŸ”„ ê¸°ì¡´ íƒ€ì´ë¨¸ interval ì •ë¦¬: ${objectId}`);
            }
            
            const localStartTime = Date.now() / 1000;
            
            localTimers.set(objectId, {
                serverStartTime,
                localStartTime,
                elapsed: elapsed,
                timeFormat,
                isRunning: true
            });
            
            // ì¦‰ì‹œ í˜„ì¬ ì‹œê°„ í‘œì‹œ
            const formattedTime = formatTime(elapsed, timeFormat);
            updateTimerDisplay(objectId, formattedTime);
            
            // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸í•˜ëŠ” ì¸í„°ë²Œ ì‹œì‘
            const interval = setInterval(() => {
                const timer = localTimers.get(objectId);
                if (!timer || !timer.isRunning) return;
                
                const currentTime = Date.now() / 1000;
                const newElapsed = timer.elapsed + (currentTime - timer.localStartTime);
                const formattedTime = formatTime(newElapsed, timer.timeFormat);
                
                // UI ì—…ë°ì´íŠ¸
                updateTimerDisplay(objectId, formattedTime);
                
                // íƒ€ì´ë¨¸ ìƒíƒœ ì—…ë°ì´íŠ¸ (localStartTimeì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
                localTimers.set(objectId, {
                    ...timer,
                    elapsed: newElapsed
                });
            }, 1000);
            
            timerIntervals.set(objectId, interval);
            console.log(`ğŸš€ ì˜¤ë²„ë ˆì´ ë¡œì»¬ íƒ€ì´ë¨¸ ì‹œì‘: ${objectId}, ì„œë²„ ì‹œì‘: ${serverStartTime}, ê²½ê³¼: ${elapsed}, ë¡œì»¬ ì‹œì‘: ${localStartTime}`);
        }
        
        // ë¡œì»¬ íƒ€ì´ë¨¸ ì •ì§€
        function stopLocalTimer(objectId, finalElapsed) {
            // ì¸í„°ë²Œ ì •ì§€
            const interval = timerIntervals.get(objectId);
            if (interval) {
                clearInterval(interval);
                timerIntervals.delete(objectId);
            }
            
            // íƒ€ì´ë¨¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            const timer = localTimers.get(objectId);
            if (timer) {
                const formattedTime = formatTime(finalElapsed, timer.timeFormat);
                updateTimerDisplay(objectId, formattedTime);
                
                localTimers.set(objectId, {
                    ...timer,
                    elapsed: finalElapsed,
                    isRunning: false
                });
            }
            
            console.log(`â¹ï¸ ì˜¤ë²„ë ˆì´ ë¡œì»¬ íƒ€ì´ë¨¸ ì •ì§€: ${objectId}, ìµœì¢… ê²½ê³¼: ${finalElapsed}`);
        }
        
        // ë¡œì»¬ íƒ€ì´ë¨¸ ë¦¬ì…‹
        function resetLocalTimer(objectId) {
            // ì¸í„°ë²Œ ì •ì§€
            const interval = timerIntervals.get(objectId);
            if (interval) {
                clearInterval(interval);
                timerIntervals.delete(objectId);
            }
            
            // íƒ€ì´ë¨¸ ìƒíƒœ ë¦¬ì…‹
            const timer = localTimers.get(objectId);
            if (timer) {
                updateTimerDisplay(objectId, '00:00');
                
                localTimers.set(objectId, {
                    ...timer,
                    elapsed: 0,
                    isRunning: false
                });
            }
            
            console.log(`ğŸ”„ ì˜¤ë²„ë ˆì´ ë¡œì»¬ íƒ€ì´ë¨¸ ë¦¬ì…‹: ${objectId}`);
        }
        
        // ë¡œì»¬ íƒ€ì´ë¨¸ ë™ê¸°í™”
        function syncLocalTimer(objectId, serverTime, serverStartTime, serverElapsed) {
            const timer = localTimers.get(objectId);
            if (!timer || !timer.isRunning) return;
            
            const currentTime = Date.now() / 1000;
            const correctedElapsed = serverElapsed;
            const formattedTime = formatTime(correctedElapsed, timer.timeFormat);
            
            // UI ì—…ë°ì´íŠ¸
            updateTimerDisplay(objectId, formattedTime);
            
            // íƒ€ì´ë¨¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            localTimers.set(objectId, {
                ...timer,
                elapsed: correctedElapsed,
                localStartTime: currentTime - correctedElapsed
            });
            
            console.log(`ğŸ”„ ì˜¤ë²„ë ˆì´ ë¡œì»¬ íƒ€ì´ë¨¸ ë™ê¸°í™”: ${objectId}, ì„œë²„ ì‹œê°„: ${serverTime}, ë³´ì •ëœ ê²½ê³¼: ${serverElapsed}`);
        }
        
        // íƒ€ì´ë¨¸ í‘œì‹œ ì—…ë°ì´íŠ¸
        function updateTimerDisplay(objectId, formattedTime) {
            console.log(`â° íƒ€ì´ë¨¸ í‘œì‹œ ì—…ë°ì´íŠ¸ ì‹œì‘: ${objectId} = ${formattedTime}`);
            
            const element = motionManager.objects.get(objectId);
            if (element) {
                console.log(`ğŸ” íƒ€ì´ë¨¸ ê°ì²´ ìš”ì†Œ ì°¾ìŒ: ${objectId}`);
                
                // SVG text ìš”ì†Œ ì°¾ê¸° (íƒ€ì´ë¨¸ ê°ì²´ìš©)
                const textElement = element.querySelector('text');
                if (textElement) {
                    const oldText = textElement.textContent;
                    textElement.textContent = formattedTime;
                    console.log(`âœ… íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${objectId} = ${oldText} â†’ ${formattedTime}`);
                } else {
                    console.log(`ğŸ” ì§ì ‘ text ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ, SVG ë‚´ë¶€ í™•ì¸`);
                    
                    // ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ í…ìŠ¤íŠ¸ ìš”ì†Œ ì°¾ê¸° ì‹œë„
                    const svgElement = element.querySelector('svg');
                    if (svgElement) {
                        console.log(`ğŸ” SVG ìš”ì†Œ ì°¾ìŒ`);
                        const svgTextElement = svgElement.querySelector('text');
                        if (svgTextElement) {
                            const oldText = svgTextElement.textContent;
                            svgTextElement.textContent = formattedTime;
                            console.log(`âœ… SVG íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${objectId} = ${oldText} â†’ ${formattedTime}`);
                        } else {
                            console.warn(`âŒ SVG ë‚´ í…ìŠ¤íŠ¸ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${objectId}`);
                            // SVG ë‚´ë¶€ì˜ ëª¨ë“  ìš”ì†Œ í™•ì¸
                            const allSvgElements = svgElement.querySelectorAll('*');
                            console.log(`ğŸ” SVG ë‚´ ëª¨ë“  ìš”ì†Œ: ${allSvgElements.length}ê°œ`);
                            allSvgElements.forEach((el, index) => {
                                console.log(`  - ìš”ì†Œ ${index + 1}: ${el.tagName}, textContent="${el.textContent}"`);
                            });
                        }
                    } else {
                        console.warn(`âŒ íƒ€ì´ë¨¸ í…ìŠ¤íŠ¸ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${objectId}`);
                        // ê°ì²´ ë‚´ë¶€ì˜ ëª¨ë“  ìš”ì†Œ í™•ì¸
                        const allElements = element.querySelectorAll('*');
                        console.log(`ğŸ” ê°ì²´ ë‚´ ëª¨ë“  ìš”ì†Œ: ${allElements.length}ê°œ`);
                        allElements.forEach((el, index) => {
                            console.log(`  - ìš”ì†Œ ${index + 1}: ${el.tagName}, textContent="${el.textContent}"`);
                        });
                    }
                }
            } else {
                console.warn(`âŒ íƒ€ì´ë¨¸ ê°ì²´ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${objectId}`);
                console.log(`ğŸ” motionManager.objectsì— ìˆëŠ” ëª¨ë“  ê°ì²´:`, Array.from(motionManager.objects.keys()));
            }
        }
        
        // ì‹œê°„ í¬ë§·íŒ… í•¨ìˆ˜
        function formatTime(elapsedSeconds, timeFormat = 'MM:SS') {
            if (timeFormat === 'SS') {
                return `${Math.floor(elapsedSeconds).toString().padStart(2, '0')}`;
            } else if (timeFormat === 'HH:MM:SS') {
                const hours = Math.floor(elapsedSeconds / 3600);
                const minutes = Math.floor((elapsedSeconds % 3600) / 60);
                const seconds = Math.floor(elapsedSeconds % 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                // ê¸°ë³¸ MM:SS í˜•ì‹
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = Math.floor(elapsedSeconds % 60);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }
        
        // ì„œë²„ì—ì„œ íƒ€ì´ë¨¸ ìƒíƒœë¥¼ ê°€ì ¸ì™€ì„œ ë™ê¸°í™”í•˜ëŠ” í•¨ìˆ˜
        async function syncTimerStatesFromServer() {
            console.log('ğŸ”„ ì„œë²„ì—ì„œ íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™” ì‹œì‘');
            
            if (!currentScene) {
                console.log('âš ï¸ í˜„ì¬ ì”¬ì´ ì—†ì–´ì„œ íƒ€ì´ë¨¸ ë™ê¸°í™” ê±´ë„ˆëœ€');
                return;
            }
            
            console.log('ğŸ” í˜„ì¬ ì”¬ ì •ë³´:', {
                id: currentScene.id,
                name: currentScene.name,
                objectsCount: currentScene.objects ? currentScene.objects.length : 0
            });
            
            // í˜„ì¬ ì”¬ì˜ íƒ€ì´ë¨¸ ê°ì²´ë“¤ ì°¾ê¸°
            const timerObjects = currentScene.objects.filter(obj => obj.type === 'text' && obj.properties.isTimer);
            console.log(`ğŸ” íƒ€ì´ë¨¸ ê°ì²´ ${timerObjects.length}ê°œ ë°œê²¬`);
            
            if (timerObjects.length === 0) {
                console.log('âš ï¸ í˜„ì¬ ì”¬ì— íƒ€ì´ë¨¸ ê°ì²´ê°€ ì—†ìŒ');
                return;
            }
            
            for (const timerObj of timerObjects) {
                console.log(`ğŸ” íƒ€ì´ë¨¸ ê°ì²´ ì •ë³´:`, {
                    id: timerObj.id,
                    name: timerObj.name,
                    properties: timerObj.properties
                });
                
                try {
                    // ì„œë²„ì—ì„œ íƒ€ì´ë¨¸ ìƒíƒœ ê°€ì ¸ì˜¤ê¸° (í”„ë¡œì íŠ¸ ì´ë¦„ í¬í•¨)
                    const projectName = '{{ project_name }}'; // í…œí”Œë¦¿ì—ì„œ í”„ë¡œì íŠ¸ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                    console.log(`ğŸŒ íƒ€ì´ë¨¸ ìƒíƒœ ìš”ì²­: /api/live/objects/${timerObj.id}/timer/status?project_name=${encodeURIComponent(projectName)}`);
                    const response = await fetch(`/api/live/objects/${timerObj.id}/timer/status?project_name=${encodeURIComponent(projectName)}`);
                    if (response.ok) {
                        const timerData = await response.json();
                        console.log(`â° íƒ€ì´ë¨¸ ${timerObj.id} ì„œë²„ ìƒíƒœ:`, timerData);
                        
                        if (timerData.timer_state && timerData.timer_state.is_running) {
                            // íƒ€ì´ë¨¸ê°€ ì‹¤í–‰ ì¤‘ì´ë©´ ë¡œì»¬ íƒ€ì´ë¨¸ ì‹œì‘
                            console.log(`ğŸš€ íƒ€ì´ë¨¸ ${timerObj.id} ì„œë²„ì—ì„œ ì‹¤í–‰ ì¤‘ - ë¡œì»¬ íƒ€ì´ë¨¸ ì‹œì‘`);
                            startLocalTimer(
                                timerObj.id,
                                timerData.timer_state.start_time,
                                timerData.timer_state.elapsed,
                                timerData.timer_state.time_format || 'MM:SS'
                            );
                        } else if (timerData.timer_state) {
                            // íƒ€ì´ë¨¸ê°€ ì •ì§€ ìƒíƒœë©´ í˜„ì¬ ì‹œê°„ë§Œ í‘œì‹œí•˜ê³  ë¡œì»¬ íƒ€ì´ë¨¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                            console.log(`â¹ï¸ íƒ€ì´ë¨¸ ${timerObj.id} ì„œë²„ì—ì„œ ì •ì§€ ìƒíƒœ - í˜„ì¬ ì‹œê°„ í‘œì‹œ`);
                            updateTimerDisplay(timerObj.id, timerData.timer_state.current_time || '00:00');
                            
                            // ë¡œì»¬ íƒ€ì´ë¨¸ ìƒíƒœë„ ì—…ë°ì´íŠ¸ (ì •ì§€ ìƒíƒœë¡œ)
                            localTimers.set(timerObj.id, {
                                serverStartTime: timerData.timer_state.start_time,
                                localStartTime: Date.now() / 1000,
                                elapsed: timerData.timer_state.elapsed || 0,
                                timeFormat: timerData.timer_state.time_format || 'MM:SS',
                                isRunning: false
                            });
                        }
                    } else {
                        console.warn(`âŒ íƒ€ì´ë¨¸ ${timerObj.id} ìƒíƒœ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`âŒ íƒ€ì´ë¨¸ ${timerObj.id} ìƒíƒœ ë™ê¸°í™” ì˜¤ë¥˜:`, error);
                }
            }
            
            console.log('âœ… íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™” ì™„ë£Œ');
        }
        
        // ì—°ê²° ìƒíƒœë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì²´í¬í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.checkWebSocketStatus = checkConnectionStatus;
        
        // í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ í›„ ì´ˆê¸° ì—°ê²° ìƒíƒœ ì²´í¬ ë° íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™”
        setTimeout(() => {
            console.log('ğŸ” Initial connection status check:');
            checkConnectionStatus();
            
            // ì„œë²„ì—ì„œ íƒ€ì´ë¨¸ ìƒíƒœ ë™ê¸°í™”
            syncTimerStatesFromServer();
        }, 1000);

        // ê°ì²´ ìƒì„± í•¨ìˆ˜
        function createObjectElement(obj) {
            const element = document.createElement('div');
            element.className = 'overlay-object';
            element.id = `obj-${obj.id}`;
            element.setAttribute('data-object-id', obj.id);
            
            // ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì„¤ì •
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';
            
            // ê°ì²´ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
            switch (obj.type) {
                case 'text': {
                    console.log('Text object properties:', obj.properties);
                    
                    // í…ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ ìƒì„±
                    const textContainer = document.createElement('div');
                    textContainer.style.display = 'flex';
                    textContainer.style.alignItems = 'center';
                    textContainer.style.justifyContent = obj.properties.textAlign === 'left' ? 'flex-start' : 
                                                       obj.properties.textAlign === 'right' ? 'flex-end' : 'center';
                    textContainer.style.width = '100%';
                    textContainer.style.height = '100%';
                    textContainer.style.boxSizing = 'border-box';

                    // SVG ìƒì„±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.overflow = 'visible';

                    // ê·¸ë¼ë°ì´ì…˜ ë˜ëŠ” ë‹¨ìƒ‰ ì ìš©
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        const { angle = 0, stops = [] } = obj.properties.gradient;
                        
                        // ê·¸ë¼ë°ì´ì…˜ ID ìƒì„±
                        const gradientId = `text-gradient-${obj.id}`;
                        
                        // linearGradient ìš”ì†Œ ìƒì„±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ê°ë„ ê³„ì‚° (0ë„ëŠ” ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½)
                        const radians = (angle * Math.PI / 180);
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ìŠ¤í†± ì¶”ê°€
                        stops.forEach(stop => {
                            const stopEl = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopEl.setAttribute('offset', `${stop.position * 100}%`);
                            stopEl.setAttribute('stop-color', stop.color);
                            stopEl.setAttribute('stop-opacity', stop.opacity ?? 1);
                            gradient.appendChild(stopEl);
                        });
                        
                        // defsì— ê·¸ë¼ë°ì´ì…˜ ì¶”ê°€
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        fillValue = obj.properties.color || '#FFFFFF';
                    }

                    // í…ìŠ¤íŠ¸ ìš”ì†Œ ìƒì„±
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = obj.properties.content || '';
                    text.setAttribute('x', '50%');
                    text.setAttribute('y', '50%');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('text-anchor', obj.properties.textAlign === 'left' ? 'start' : 
                                                   obj.properties.textAlign === 'right' ? 'end' : 'middle');
                    text.setAttribute('font-family', obj.properties.fontFamily || 'Arial');
                    text.setAttribute('font-size', `${obj.properties.fontSize || 24}px`);
                    text.setAttribute('font-weight', obj.properties.fontWeight || 'normal');
                    text.setAttribute('fill', fillValue);
                    text.setAttribute('fill-opacity', obj.properties.fillType === 'gradient' ? 1 : (obj.properties.opacity ?? 1));

                    // í…ìŠ¤íŠ¸ í…Œë‘ë¦¬
                    if (obj.properties.useTextBorder) {
                        text.setAttribute('stroke', obj.properties.textBorderColor || '#000000');
                        text.setAttribute('stroke-width', obj.properties.textBorderWidth || 1);
                    }

                    // í…ìŠ¤íŠ¸ ê·¸ë¦¼ì
                    if (obj.properties.useTextShadow) {
                        const shadowX = obj.properties.textShadowOffsetX || 0;
                        const shadowY = obj.properties.textShadowOffsetY || 0;
                        const shadowBlur = obj.properties.textShadowBlur || 0;
                        const shadowColor = obj.properties.textShadowColor || '#000000';
                        text.style.filter = `drop-shadow(${shadowX}px ${shadowY}px ${shadowBlur}px ${shadowColor})`;
                    }

                    svg.appendChild(text);
                    textContainer.appendChild(svg);
                    element.appendChild(textContainer);
                    break;
                }

                case 'image':
                    const img = document.createElement('img');
                    
                    // ì‚¬ìš©ìë³„ ì´ë¯¸ì§€ URL ìƒì„±
                    let imgSrc = obj.properties.src || '';
                    const userId = {{ user_id }};
                    
                    // ì´ë¯¸ì§€ URLì— ì‚¬ìš©ì ID ì¶”ê°€ (í”„ë¡œì íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ë¯¸ì§€ì¸ ê²½ìš°)
                    if (imgSrc.includes('/projects/') && imgSrc.includes('/library/images/') && userId) {
                        const separator = imgSrc.includes('?') ? '&' : '?';
                        imgSrc += `${separator}user_id=${userId}`;
                    }
                    
                    img.src = imgSrc;
                    img.style.width = obj.properties.width ? obj.properties.width + 'px' : '100%';
                    img.style.height = obj.properties.height ? obj.properties.height + 'px' : '100%';
                    img.style.objectFit = 'contain';
                    img.style.display = 'block';
                    img.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    element.style.setProperty('--target-opacity', obj.properties.opacity !== undefined ? obj.properties.opacity : 1);
                    element.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    element.appendChild(img);
                    break;
                    
                case 'shape': {
                    const width = obj.properties.width || 100;
                    const height = obj.properties.height || 100;
                    const opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    const cornerRadius = obj.properties.cornerRadius || {
                        topLeft: 0,
                        topRight: 0,
                        bottomLeft: 0,
                        bottomRight: 0
                    };

                    // SVG ì»¨í…Œì´ë„ˆ ìƒì„±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    svg.style.display = 'block';
                    svg.style.width = '100%';
                    svg.style.height = '100%';

                    // ê·¸ë¼ë°ì´ì…˜ ë˜ëŠ” ë‹¨ìƒ‰ ì±„ìš°ê¸° ì„¤ì •
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        // ê·¸ë¼ë°ì´ì…˜ ID ìƒì„±
                        const gradientId = `gradient-${obj.id}`;
                        
                        // linearGradient ìš”ì†Œ ìƒì„±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ê°ë„ ì„¤ì • (0ë„ëŠ” ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½)
                        const angle = obj.properties.gradient.angle || 0;
                        const radians = angle * (Math.PI / 180);
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ìŠ¤í†± ì¶”ê°€
                        const stops = obj.properties.gradient.stops || [
                            {color: '#FF0000', opacity: 1, position: 0},
                            {color: '#0000FF', opacity: 1, position: 1}
                        ];
                        
                        stops.forEach(stop => {
                            const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopElement.setAttribute('offset', `${stop.position * 100}%`);
                            stopElement.setAttribute('stop-color', stop.color);
                            stopElement.setAttribute('stop-opacity', stop.opacity);
                            gradient.appendChild(stopElement);
                        });
                        
                        // defsì— ê·¸ë¼ë°ì´ì…˜ ì¶”ê°€
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        // ë‹¨ìƒ‰ ì±„ìš°ê¸°
                        fillValue = obj.properties.color || '#FF0000';
                    }

                    let shapeElement;
                    if (obj.properties.shapeType === 'triangle') {
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        shapeElement.setAttribute('points', `${width/2},0 0,${height} ${width},${height}`);
                    } else if (obj.properties.shapeType === 'circle' || obj.properties.shapeType === 'ellipse') {
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                        shapeElement.setAttribute('cx', width/2);
                        shapeElement.setAttribute('cy', height/2);
                        shapeElement.setAttribute('rx', width/2);
                        shapeElement.setAttribute('ry', height/2);
                    } else {
                        // ì‚¬ê°í˜• (box)
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        
                        // SVG path ìƒì„±
                        const path = [
                            `M${cornerRadius.topLeft},0`, // ì‹œì‘ì  (ì¢Œìƒë‹¨)
                            `h${width - cornerRadius.topLeft - cornerRadius.topRight}`, // ìƒë‹¨ ê°€ë¡œì„ 
                            `q${cornerRadius.topRight},0 ${cornerRadius.topRight},${cornerRadius.topRight}`, // ìš°ìƒë‹¨ ëª¨ì„œë¦¬
                            `v${height - cornerRadius.topRight - cornerRadius.bottomRight}`, // ìš°ì¸¡ ì„¸ë¡œì„ 
                            `q0,${cornerRadius.bottomRight} -${cornerRadius.bottomRight},${cornerRadius.bottomRight}`, // ìš°í•˜ë‹¨ ëª¨ì„œë¦¬
                            `h-${width - cornerRadius.bottomRight - cornerRadius.bottomLeft}`, // í•˜ë‹¨ ê°€ë¡œì„ 
                            `q-${cornerRadius.bottomLeft},0 -${cornerRadius.bottomLeft},-${cornerRadius.bottomLeft}`, // ì¢Œí•˜ë‹¨ ëª¨ì„œë¦¬
                            `v-${height - cornerRadius.bottomLeft - cornerRadius.topLeft}`, // ì¢Œì¸¡ ì„¸ë¡œì„ 
                            `q0,-${cornerRadius.topLeft} ${cornerRadius.topLeft},-${cornerRadius.topLeft}`, // ì¢Œìƒë‹¨ ëª¨ì„œë¦¬
                            'z' // ë‹«ê¸°
                        ].join(' ');
                        
                        shapeElement.setAttribute('d', path);
                    }

                    shapeElement.setAttribute('fill', fillValue);
                    shapeElement.setAttribute('opacity', opacity);

                    if (obj.properties.useShapeBorder) {
                        shapeElement.setAttribute('stroke', obj.properties.shapeBorderColor || '#FFFFFF');
                        shapeElement.setAttribute('stroke-width', obj.properties.shapeBorderWidth || 1);
                    }

                    if (obj.properties.useShapeShadow) {
                        shapeElement.style.filter = `drop-shadow(${obj.properties.shapeShadowOffsetX||0}px ${obj.properties.shapeShadowOffsetY||0}px ${obj.properties.shapeShadowBlur||0}px ${obj.properties.shapeShadowColor||'#000'})`;
                    }

                    svg.appendChild(shapeElement);
                    element.appendChild(svg);
                    break;
                }

                case 'timer': {
                    console.log('Timer object properties:', obj.properties);
                    
                    // íƒ€ì´ë¨¸ ì»¨í…Œì´ë„ˆ ìƒì„±
                    const timerContainer = document.createElement('div');
                    timerContainer.style.display = 'flex';
                    timerContainer.style.alignItems = 'center';
                    timerContainer.style.justifyContent = obj.properties.textAlign === 'left' ? 'flex-start' : 
                                                        obj.properties.textAlign === 'right' ? 'flex-end' : 'center';
                    timerContainer.style.width = '100%';
                    timerContainer.style.height = '100%';
                    timerContainer.style.boxSizing = 'border-box';

                    // SVG ìƒì„±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.overflow = 'visible';

                    // ê·¸ë¼ë°ì´ì…˜ ë˜ëŠ” ë‹¨ìƒ‰ ì ìš©
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        const { angle = 0, stops = [] } = obj.properties.gradient;
                        
                        // ê·¸ë¼ë°ì´ì…˜ ID ìƒì„±
                        const gradientId = `timer-gradient-${obj.id}`;
                        
                        // linearGradient ìš”ì†Œ ìƒì„±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ê°ë„ ê³„ì‚° (0ë„ëŠ” ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½)
                        const radians = angle * Math.PI / 180;
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // ê·¸ë¼ë°ì´ì…˜ ìŠ¤í†± ì¶”ê°€
                        stops.forEach(stop => {
                            const stopEl = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopEl.setAttribute('offset', `${stop.position * 100}%`);
                            stopEl.setAttribute('stop-color', stop.color);
                            stopEl.setAttribute('stop-opacity', stop.opacity ?? 1);
                            gradient.appendChild(stopEl);
                        });
                        
                        // defsì— ê·¸ë¼ë°ì´ì…˜ ì¶”ê°€
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        fillValue = obj.properties.color || '#FFFFFF';
                    }

                    // íƒ€ì´ë¨¸ í…ìŠ¤íŠ¸ ìš”ì†Œ ìƒì„±
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = obj.properties.content || '00:00';
                    text.setAttribute('x', '50%');
                    text.setAttribute('y', '50%');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('text-anchor', obj.properties.textAlign === 'left' ? 'start' : 
                                                   obj.properties.textAlign === 'right' ? 'end' : 'middle');
                    text.setAttribute('font-family', obj.properties.fontFamily || 'Arial');
                    text.setAttribute('font-size', `${obj.properties.fontSize || 48}px`);
                    text.setAttribute('font-weight', obj.properties.fontWeight || 'bold');
                    text.setAttribute('fill', fillValue);
                    text.setAttribute('fill-opacity', obj.properties.fillType === 'gradient' ? 1 : (obj.properties.opacity ?? 1));

                    svg.appendChild(text);
                    timerContainer.appendChild(svg);
                    element.appendChild(timerContainer);
                    break;
                }

                case 'sequence':
                    // ì‹œí€€ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ìº”ë²„ìŠ¤ ìƒì„±
                    const canvas = document.createElement('canvas');
                    canvas.width = obj.properties.width || obj.properties.frameWidth || 100;
                    canvas.height = obj.properties.height || obj.properties.frameHeight || 100;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.display = 'block';
                    
                    // íˆ¬ëª…ë„ ì§€ì›ì„ ìœ„í•œ ìº”ë²„ìŠ¤ ì„¤ì •
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // ì‹œí€€ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ë³€ìˆ˜
                    let currentFrame = obj.properties.currentFrame || 0;
                    let frameCount = obj.properties.frameCount || 1;
                    let frameWidth = obj.properties.frameWidth || 100;
                    let frameHeight = obj.properties.frameHeight || 100;
                    let fps = obj.properties.fps || 24;
                    let spriteUrl = obj.properties.spriteUrl || '';
                    let spriteImage = null;
                    let animationInterval = null;
                    
                    // ìŠ¤í”„ë¼ì´íŠ¸ ì´ë¯¸ì§€ ë¡œë“œ
                    if (spriteUrl) {
                        const img = new Image();
                        img.crossOrigin = 'anonymous'; // CORS ì„¤ì •
                        img.onload = function() {
                            spriteImage = img;
                            drawFrame();
                        };
                        img.onerror = function() {
                            console.error('Failed to load sprite image:', spriteUrl);
                        };
                        img.src = spriteUrl;
                    }
                    
                    // í”„ë ˆì„ ê·¸ë¦¬ê¸° í•¨ìˆ˜
                    function drawFrame() {
                        if (!spriteImage || !ctx) return;
                        
                        // ìº”ë²„ìŠ¤ í´ë¦¬ì–´ (íˆ¬ëª…í•˜ê²Œ)
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // í˜„ì¬ í”„ë ˆì„ ê·¸ë¦¬ê¸° (íˆ¬ëª…ë„ ìœ ì§€)
                        ctx.drawImage(
                            spriteImage,
                            0, frameHeight * currentFrame, // ì†ŒìŠ¤ x, y
                            frameWidth, frameHeight,        // ì†ŒìŠ¤ width, height
                            0, 0,                          // ëŒ€ìƒ x, y
                            canvas.width, canvas.height     // ëŒ€ìƒ width, height
                        );
                    }
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    function startAnimation() {
                        if (animationInterval) return;
                        animationInterval = setInterval(() => {
                            if (obj.properties.loop === false) {
                                // ë§ˆì§€ë§‰ í”„ë ˆì„ì´ë©´ ë©ˆì¶¤
                                if (currentFrame >= frameCount - 1) {
                                    stopAnimation();
                                    return;
                                }
                                currentFrame++;
                            } else {
                                // ë£¨í”„ì¼ ë•Œë§Œ ë°˜ë³µ
                                currentFrame = (currentFrame + 1) % frameCount;
                            }
                            drawFrame();
                        }, 1000 / fps);
                    }
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì •ì§€
                    function stopAnimation() {
                        if (animationInterval) {
                            clearInterval(animationInterval);
                            animationInterval = null;
                        }
                    }
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ë¦¬ì…‹
                    function resetAnimation() {
                        stopAnimation();
                        currentFrame = 0;
                        drawFrame();
                    }
                    
                    // ì‹œí€€ìŠ¤ ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                    socket.on('sequence_control', (data) => {
                        if (data.sequence_id === obj.id) {
                            switch (data.action) {
                                case 'play':
                                    startAnimation();
                                    break;
                                case 'pause':
                                    stopAnimation();
                                    break;
                                case 'reset':
                                    resetAnimation();
                                    break;
                                case 'setFrame':
                                    currentFrame = Math.max(0, Math.min(data.frame, frameCount - 1));
                                    drawFrame();
                                    break;
                            }
                        }
                    });
                    
                    // ìë™ ì¬ìƒ ì„¤ì •
                    if (obj.properties.autoPlay !== false) {
                        startAnimation();
                    }
                    
                    element.appendChild(canvas);
                    break;
            }
            
            // ìœ„ì¹˜ ë° í¬ê¸° ì„¤ì •
            element.style.left = `${obj.properties.x || 0}px`;
            element.style.top = `${obj.properties.y || 0}px`;
            element.style.width = `${obj.properties.width || 100}px`;
            element.style.height = `${obj.properties.height || 100}px`;
            
            // íˆ¬ëª…ë„ ì„¤ì •
            element.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
            
            // íšŒì „ ì„¤ì •
            if (obj.properties.rotation !== undefined && obj.properties.rotation !== null) {
                console.log(`Applying rotation to object ${obj.id}: ${obj.properties.rotation}deg`);
                // CSS ë³€ìˆ˜ë¡œ íšŒì „ê°’ ì„¤ì • (ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ì‚¬ìš©)
                element.style.setProperty('--rotation', `${obj.properties.rotation}deg`);
                // transform-originì„ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •
                element.style.transformOrigin = 'center center';
                // íšŒì „ transform ì ìš©
                element.style.transform = `rotate(${obj.properties.rotation}deg)`;
                // íšŒì „ì´ í™•ì‹¤íˆ ì ìš©ë˜ë„ë¡ ê°•ì œ ì„¤ì •
                element.style.setProperty('transform', `rotate(${obj.properties.rotation}deg)`, 'important');
                // ì¶”ê°€ë¡œ CSS í´ë˜ìŠ¤ë¥¼ í†µí•œ íšŒì „ ì ìš©
                element.classList.add('rotated-object');
                element.setAttribute('data-rotation', obj.properties.rotation);
                console.log(`Final transform for object ${obj.id}: rotate(${obj.properties.rotation}deg)`);
                console.log(`CSS variable --rotation set to: ${obj.properties.rotation}deg`);
            } else {
                // íšŒì „ê°’ì´ ì—†ìœ¼ë©´ 0ë„ë¡œ ì„¤ì •
                element.style.setProperty('--rotation', '0deg');
            }
            
            // ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚œ í›„ opacityë¥¼ --target-opacityë¡œ ê°•ì œ ë®ì–´ì“°ê¸°
            element.addEventListener('animationend', function() {
                const targetOpacity = element.style.getPropertyValue('--target-opacity') || 1;
                element.style.opacity = targetOpacity;
            });
            
            return element;
        }

        function applyObjectStyles(element, object) {
            const properties = object.properties || {};
            element.style.left = `${properties.x || 0}px`;
            element.style.top = `${properties.y || 0}px`;
            element.style.width = `${properties.width || 200}px`;
            element.style.height = `${properties.height || 100}px`;
            element.style.opacity = properties.opacity ?? 1;

            // ëª¨ì„œë¦¬ ë‘¥ê¸€ê¸° ì²˜ë¦¬
            if (properties.cornerRadius) {
                element.style.borderTopLeftRadius = `${properties.cornerRadius.topLeft || 0}px`;
                element.style.borderTopRightRadius = `${properties.cornerRadius.topRight || 0}px`;
                element.style.borderBottomLeftRadius = `${properties.cornerRadius.bottomLeft || 0}px`;
                element.style.borderBottomRightRadius = `${properties.cornerRadius.bottomRight || 0}px`;
            }

            // íšŒì „ ì²˜ë¦¬
            if (properties.rotation !== undefined && properties.rotation !== null) {
                element.style.setProperty('--rotation', `${properties.rotation}deg`);
                element.style.transform = `rotate(${properties.rotation}deg)`;
            } else {
                element.style.setProperty('--rotation', '0deg');
            }
        }
    </script>
</body>
</html> 