<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: transparent;
        }
        #overlay-container {
            position: fixed;
            top: 0;
            left: 0;
            width: {{ canvas_width }}px;
            height: {{ canvas_height }}px;
            pointer-events: none;
            background: transparent;
        }
        .overlay-object {
            position: absolute;
            pointer-events: none;
            transform-origin: center center;
            --target-opacity: 1;
        }
        
        /* ÌöåÏ†ÑÎêú Í∞ùÏ≤¥Î•º ÏúÑÌïú Ï∂îÍ∞Ä Ïä§ÌÉÄÏùº */
        .rotated-object {
            transform-origin: center center !important;
        }
        /* Ìö®Í≥º Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .fadeIn {
            animation: fadeIn 1s ease-in;
        }
        .fadeOut {
            animation: fadeOut 1s ease-out;
        }
        .slideUpIn {
            animation: slideUpIn 1s ease-in;
        }
        .slideUpOut {
            animation: slideUpOut 1s ease-out;
        }
        .slideDownIn {
            animation: slideDownIn 1s ease-in;
        }
        .slideDownOut {
            animation: slideDownOut 1s ease-out;
        }
        .slideLeftIn {
            animation: slideLeftIn 1s ease-in;
        }
        .slideLeftOut {
            animation: slideLeftOut 1s ease-out;
        }
        .slideRightIn {
            animation: slideRightIn 1s ease-in;
        }
        .slideRightOut {
            animation: slideRightOut 1s ease-out;
        }
        .scaleIn {
            animation: scaleIn 1s ease-in;
        }
        .scaleOut {
            animation: scaleOut 1s ease-out;
        }
        .rotateIn {
            animation: rotateIn 1s ease-in;
        }
        .rotateOut {
            animation: rotateOut 1s ease-out;
        }
        .bounceIn {
            animation: bounceIn 1s cubic-bezier(0.36, 0, 0.66, -0.56);
        }
        .bounceOut {
            animation: bounceOut 1s cubic-bezier(0.36, 0, 0.66, -0.56);
        }
        .elasticIn {
            animation: elasticIn 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .elasticOut {
            animation: elasticOut 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        .zoomIn {
            animation: zoomIn 1s ease-in;
        }
        .zoomOut {
            animation: zoomOut 1s ease-out;
        }
        /* Ïª§Îãù Í∞ïÏ†ú Ï†ÅÏö© */
        .overlay-object * {
            letter-spacing: 0px !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: var(--target-opacity, 1); }
        }
        @keyframes fadeOut {
            from { opacity: var(--target-opacity, 1); }
            to { opacity: 0; }
        }
        @keyframes slideUpIn {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideUpOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-100%); opacity: 0; }
        }
        @keyframes slideDownIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideDownOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(100%); opacity: 0; }
        }
        @keyframes slideLeftIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideLeftOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-100%); opacity: 0; }
        }
        @keyframes slideRightIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideRightOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        @keyframes scaleIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes scaleOut {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0); opacity: 0; }
        }
        @keyframes rotateIn {
            from { transform: rotate(360deg); opacity: 0; }
            to { transform: rotate(0deg); opacity: 1; }
        }
        @keyframes rotateOut {
            from { transform: rotate(0deg); opacity: 1; }
            to { transform: rotate(360deg); opacity: 0; }
        }
        @keyframes bounceIn {
            0% { transform: translateY(100%); opacity: 0; }
            50% { transform: translateY(-20%); opacity: 1; }
            70% { transform: translateY(10%); opacity: 1; }
            85% { transform: translateY(-5%); opacity: 1; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes bounceOut {
            0% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(-20%); opacity: 1; }
            70% { transform: translateY(10%); opacity: 1; }
            85% { transform: translateY(-5%); opacity: 1; }
            100% { transform: translateY(100%); opacity: 0; }
        }
        @keyframes elasticIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            70% { transform: scale(0.9); opacity: 1; }
            85% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes elasticOut {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 1; }
            70% { transform: scale(0.9); opacity: 1; }
            85% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.3); opacity: 0; }
        }
        @keyframes zoomIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes zoomOut {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="overlay-container"></div>
    <script>
        // ÌîÑÎ¶¨Î°úÎî© Ï∫êÏãú
        let preloadCache = null;
        let isPreloading = false;
        
        // ÌîÑÎ¶¨Î°úÎî© Ìï®Ïàò
        async function preloadProjectData(projectName) {
            if (isPreloading) return;
            isPreloading = true;
            
            try {
                console.log('ÌîÑÎ¶¨Î°úÎî© ÏãúÏûë:', projectName);
                const response = await fetch(`/api/preload/${encodeURIComponent(projectName)}`);
                if (response.ok) {
                    preloadCache = await response.json();
                    console.log('ÌîÑÎ¶¨Î°úÎî© ÏôÑÎ£å:', preloadCache);
                    
                    // Ïù¥ÎØ∏ÏßÄ Î¶¨ÏÜåÏä§ ÌîÑÎ¶¨Î°úÎî©
                    preloadImages(preloadCache);
                }
            } catch (error) {
                console.warn('ÌîÑÎ¶¨Î°úÎî© Ïã§Ìå®:', error);
            } finally {
                isPreloading = false;
            }
        }
        
        // Ïù¥ÎØ∏ÏßÄ Î¶¨ÏÜåÏä§ ÌîÑÎ¶¨Î°úÎî©
        function preloadImages(cache) {
            if (!cache.scenes) return;
            
            const imageUrls = new Set();
            cache.scenes.forEach(scene => {
                scene.objects.forEach(obj => {
                    if (obj.type === 'image' && obj.properties.src) {
                        imageUrls.add(obj.properties.src);
                    }
                });
            });
            
            console.log('Ïù¥ÎØ∏ÏßÄ ÌîÑÎ¶¨Î°úÎî© ÏãúÏûë:', imageUrls.size, 'Í∞ú');
            imageUrls.forEach(url => {
                const img = new Image();
                img.src = url;
            });
        }
        
        // Î™®ÏÖò Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§
        class MotionManager {
            constructor(container) {
                this.container = container;
                this.objects = new Map();
                this.currentScene = null;
            }

            // Ïù∏Î™®ÏÖò Ï†ÅÏö©
            applyInMotion(element, obj) {
                const motion = obj.in_motion || { type: 'none' };
                const style = this.getMotionStyle(motion, true);
                Object.assign(element.style, style);
                const className = `${motion.type === 'none' ? 'fade' : motion.type}In`;
                element.classList.add(className);
                return new Promise((resolve) => {
                    element.addEventListener('animationend', () => {
                        element.classList.remove(className);
                        element.style.animation = 'none';
                        
                        // Ïò§Î∏åÏ†ùÌä∏Ïùò ÏõêÎûò rotation transformÏùÑ Îã§Ïãú Ï†ÅÏö©
                        if (obj.properties.rotation !== undefined && obj.properties.rotation !== null) {
                            const rotationTransform = `rotate(${obj.properties.rotation}deg)`;
                            element.style.transform = rotationTransform;
                            element.style.setProperty('transform', rotationTransform, 'important');
                        } else if (style.transform) {
                            element.style.transform = style.transform;
                        }
                        
                        if (style.opacity) element.style.opacity = style.opacity;
                        element.dataset.inMotionCompleted = 'true';
                        this.checkAllInMotionsCompleted();
                        resolve();
                    }, { once: true });
                });
            }

            // ÏïÑÏõÉÎ™®ÏÖò Ï†ÅÏö©
            applyOutMotion(element, obj) {
                const motion = obj.out_motion || { type: 'none' };
                const style = this.getMotionStyle(motion, false);
                Object.assign(element.style, style);
                const className = `${motion.type === 'none' ? 'fade' : motion.type}Out`;
                element.classList.add(className);
                return new Promise((resolve) => {
                    element.addEventListener('animationend', () => {
                        element.classList.remove(className);
                        element.style.animation = '';
                        element.style.animationDuration = '';
                        element.style.animationDelay = '';
                        element.style.animationFillMode = '';
                        element.style.animationTimingFunction = '';
                        element.style.display = 'none';
                        resolve();
                    }, { once: true });
                });
            }

            // Î™®Îì† Ïù∏Î™®ÏÖò ÏôÑÎ£å ÌôïÏù∏
            checkAllInMotionsCompleted() {
                const allElements = this.container.querySelectorAll('.overlay-object');
                const allCompleted = Array.from(allElements).every(el => el.dataset.inMotionCompleted === 'true');
                
                if (allCompleted) {
                    console.log('All in-motions completed, waiting for out-motion trigger...');
                }
            }

            // Î™®Îì† ÏïÑÏõÉÎ™®ÏÖò ÏôÑÎ£å ÎåÄÍ∏∞
            async waitForAllOutMotions() {
                const elements = this.container.querySelectorAll('.overlay-object');
                const outMotionPromises = [];
                
                console.log('Checking out motions for', elements.length, 'elements');
                console.log('Current scene:', this.currentScene);
                console.log('Current scene objects:', this.currentScene?.objects);

                elements.forEach(element => {
                    const objId = element.getAttribute('data-object-id');
                    console.log('Element objId:', objId);
                    console.log('Looking for object with ID:', objId);
                    console.log('Available object IDs:', this.currentScene?.objects?.map(o => o.id));
                    
                    const obj = this.currentScene.objects.find(o => o.id === parseInt(objId));
                    console.log('Found object:', obj);
                    
                    if (obj && obj.out_motion && obj.out_motion.type !== 'none') {
                        console.log('Applying out motion for object:', obj.id, 'type:', obj.out_motion.type);
                        outMotionPromises.push(this.applyOutMotion(element, obj));
                    } else {
                        console.log('No out motion for object:', objId, 'out_motion:', obj?.out_motion);
                        // ÏïÑÏõÉÎ™®ÏÖòÏù¥ ÏóÜÎäî Í∞ùÏ≤¥ÎèÑ display:none Ï≤òÎ¶¨
                        outMotionPromises.push(Promise.resolve().then(() => {
                            element.style.display = 'none';
                        }));
                    }
                });

                console.log('Total out motion promises:', outMotionPromises.length);

                if (outMotionPromises.length === 0) {
                    return true;
                }

                await Promise.all(outMotionPromises);
                // Î™®Îì† Ïò§Î∏åÏ†ùÌä∏Ïóê ÎåÄÌï¥ display:noneÏùÑ Ìïú Î≤à Îçî Î≥¥Ïû•Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
                const allElements = this.container.querySelectorAll('.overlay-object');
                allElements.forEach(element => {
                    element.style.display = 'none';
                });
                return true;
            }

            // Î™®ÏÖò Ïä§ÌÉÄÏùº Í≥ÑÏÇ∞
            getMotionStyle(motion, isIn) {
                // 'none'ÎèÑ 2ÌîÑÎ†àÏûÑ(0.033Ï¥à)ÏßúÎ¶¨ ÌéòÏù¥Îìú Ìö®Í≥ºÎ°ú Ï≤òÎ¶¨
                let type = motion?.type || 'none';
                let duration = (type === 'none') ? 0.033 : (motion.duration || 1);
                let delay = motion.delay || 0;
                let easing = motion.easing || 'ease';
                let transform = '';
                let opacity = '';
                switch (type) {
                    case 'none':
                    case 'fade':
                        opacity = isIn ? '1' : '0';
                        break;
                    case 'slide_up':
                        transform = isIn ? 'translateY(0)' : 'translateY(100%)';
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_down':
                        transform = isIn ? 'translateY(0)' : 'translateY(-100%)';
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_left':
                        transform = isIn ? 'translateX(0)' : 'translateX(100%)';
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'slide_right':
                        transform = isIn ? 'translateX(0)' : 'translateX(-100%)';
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'zoom_in':
                        transform = isIn ? 'scale(1)' : 'scale(0)';
                        opacity = isIn ? '0' : '1';
                        break;
                    case 'zoom_out':
                        transform = isIn ? 'scale(1)' : 'scale(2)';
                        opacity = isIn ? '0' : '1';
                        break;
                    default:
                        opacity = '';
                        break;
                }
                return {
                    animation: `${type === 'none' ? 'fade' : type}${isIn ? 'In' : 'Out'} ${duration}s ${easing} ${delay}s`,
                    animationFillMode: 'forwards',
                    animationTimingFunction: easing,
                    transform: transform,
                    opacity: opacity
                };
            }

            // Ïî¨ ÏóÖÎç∞Ïù¥Ìä∏
            updateScene(scene, skipInMotion = false) {
                this.currentScene = scene;
                this.container.innerHTML = '';
                this.objects.clear();
                
                [...(scene.objects || [])]
                  .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))
                  .forEach(obj => {
                    const element = createObjectElement(obj);
                    if (element) {
                        this.container.appendChild(element);
                        this.objects.set(obj.id, element);
                        if (!skipInMotion) {
                            // startTime, endTime Ï†ÅÏö©
                            const timing = typeof obj.timing === 'string' ? JSON.parse(obj.timing) : (obj.timing || {});
                            const startTime = timing.startTime || 0;
                            const endTime = timing.endTime || (timing.duration || 5);

                            // Ïù∏Î™®ÏÖò ÏãúÏûë Ï†ÑÏóêÎäî Ïà®ÍπÄ
                            element.style.display = 'none';

                            // Ïù∏Î™®ÏÖò(Îì±Ïû•)
                            setTimeout(() => {
                                element.style.display = 'block';
                                this.applyInMotion(element, obj);
                            }, startTime * 1000);

                            // ÏïÑÏõÉÎ™®ÏÖòÏùÄ scene_out Ïù¥Î≤§Ìä∏ÏóêÏÑúÎßå Ïã§ÌñâÎêòÎèÑÎ°ù ÏòàÏïΩÌïòÏßÄ ÏïäÏùå
                            // (endTime Ï†ïÎ≥¥Îäî Ï†ÄÏû•Ìï¥ÎëêÍ∏∞Îßå Ìï®)
                            element.dataset.endTime = endTime;
                        } else {
                            // Ïù∏Î™®ÏÖò Ïä§ÌÇµ Ïãú ÏµúÏ¢Ö ÏÉÅÌÉúÎ°ú Î∞îÎ°ú ÏÑ§Ï†ï
                            if (obj.in_motion && obj.in_motion.type !== 'none') {
                                const style = this.getMotionStyle(obj.in_motion, true);
                                if (style.transform) element.style.transform = style.transform;
                                if (style.opacity) element.style.opacity = style.opacity;
                            }
                            element.dataset.inMotionCompleted = 'true';
                        }
                    }
                  });
            }
        }

        // Ï†ÑÏó≠ Î≥ÄÏàò Î∞è Ï¥àÍ∏∞Ìôî
        const socket = io();
        const container = document.getElementById('overlay-container');
        const motionManager = new MotionManager(container);
        let currentScene = null; // Ï¥àÍ∏∞ÏóêÎäî nullÎ°ú ÏÑ§Ï†ï
        let skipInMotion = sessionStorage.getItem('skipInMotion') === 'true';
        let isBroadcasting = true; // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú trueÎ°ú ÏÑ§Ï†ï

        // === WebSocket Ïó∞Í≤∞ ÏÉÅÌÉú ÎîîÎ≤ÑÍπÖ ===
        console.log('üîå Initializing WebSocket connection...');
        console.log('Socket.IO version:', io.version);
        
        // Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨ Ìï®Ïàò
        function checkConnectionStatus() {
            console.log('üì° WebSocket Status:');
            console.log('  - Connected:', socket.connected);
            console.log('  - Socket ID:', socket.id);
            console.log('  - Transport:', socket.io.engine?.transport?.name);
            console.log('  - Ready State:', socket.io.engine?.readyState);
            return socket.connected;
        }

        // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Ïó∞Í≤∞ ÏÉÅÌÉú Ï≤¥ÌÅ¨ (10Ï¥àÎßàÎã§)
        setInterval(checkConnectionStatus, 10000);

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞ Ïî¨ ÏÑ§Ï†ï
        const projectName = '{{ project.name }}';
        {% if scene %}
        const initialScene = {{ scene|tojson }};
        console.log('Initial scene loaded:', initialScene);
        currentScene = initialScene;
        // Ï¥àÍ∏∞ Ïî¨ Î†åÎçîÎßÅ (Ïù∏Î™®ÏÖò Ï†ÅÏö©)
        motionManager.updateScene(initialScene, false);
        {% else %}
        console.log('No initial scene provided');
        {% endif %}

        // ÏõπÏÜåÏºì Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
        socket.on('connect', () => {
            console.log('‚úÖ WebSocket connected successfully!');
            console.log('Socket ID:', socket.id);
            console.log('Transport:', socket.io.engine.transport.name);
            
            const projectId = {{ project.id }};
            {% if scene %}
            const sceneId = {{ scene.id }};
            console.log('üè† Joining scene room:', sceneId);
            socket.emit('join_scene', { scene_id: sceneId });
            {% else %}
            console.log('üè† Joining project room:', projectId);
            socket.emit('join_project', { project_id: projectId });
            {% endif %}
        });

        socket.on('disconnect', (reason) => {
            console.log('‚ùå WebSocket disconnected:', reason);
            console.log('Will attempt to reconnect...');
        });

        socket.on('connect_error', (error) => {
            console.error('üö´ WebSocket connection error:', error);
        });

        socket.on('reconnect', (attemptNumber) => {
            console.log('üîÑ WebSocket reconnected after', attemptNumber, 'attempts');
        });

        socket.on('reconnect_error', (error) => {
            console.error('üîÑ‚ùå WebSocket reconnection error:', error);
        });

        // Î∞©ÏÜ° ÏãúÏûë Ïã†Ìò∏Í∞Ä Ïò§Î©¥ Í∑∏ÎïåÎ∂ÄÌÑ∞ Ïî¨ Ï†ÅÏö©
        socket.on('start_broadcast', () => {
            console.log('üì∫ Broadcast started');
            isBroadcasting = true;
            // ÌïÑÏöîÏãú ÏÑúÎ≤ÑÏóê Ïî¨ Îç∞Ïù¥ÌÑ∞ ÏöîÏ≤≠
            socket.emit('request_scene');
        });

        // Ïî¨ Îç∞Ïù¥ÌÑ∞Îäî Î∞©ÏÜ° ÏãúÏûë Ï†ÑÍπåÏßÄ Î¨¥Ïãú
        socket.on('scene_update', (scene) => {
            console.log('üé¨ Scene update event received:', scene);
            if (scene.id === currentScene?.id) {
                currentScene = scene;
                motionManager.updateScene(scene);
            }
        });

        // Í∞ùÏ≤¥ ÏÜçÏÑ± ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
        socket.on('object_update', (data) => {
            console.log('üéØ Object update event received:', data);
            
            if (!currentScene) return;
            
            // ÌòÑÏû¨ Ïî¨Ïùò Í∞ùÏ≤¥ Î™©Î°ùÏóêÏÑú ÏóÖÎç∞Ïù¥Ìä∏Ìï† Í∞ùÏ≤¥ Ï∞æÍ∏∞
            const objIndex = currentScene.objects.findIndex(obj => obj.id === data.object_id);
            if (objIndex === -1) return;
            
            // Í∞ùÏ≤¥ ÏÜçÏÑ± ÏóÖÎç∞Ïù¥Ìä∏
            currentScene.objects[objIndex] = {
                ...currentScene.objects[objIndex],
                ...data.object
            };
            
            // Í∏∞Ï°¥ Í∞ùÏ≤¥ ÏöîÏÜå Ï†úÍ±∞
            const oldElement = motionManager.objects.get(data.object_id);
            if (oldElement) {
                oldElement.remove();
                motionManager.objects.delete(data.object_id);
            }
            
            // ÏÉà Í∞ùÏ≤¥ ÏöîÏÜå ÏÉùÏÑ± Î∞è Ï∂îÍ∞Ä
            const newElement = createObjectElement(currentScene.objects[objIndex]);
            if (newElement) {
                motionManager.container.appendChild(newElement);
                motionManager.objects.set(data.object_id, newElement);
                newElement.dataset.inMotionCompleted = 'true';
            }
        });

        socket.on('scene_change', async function(data) {
            console.log('üé¨ Scene change event received:', data);
            console.log('Current scene ID:', currentScene?.id);
            console.log('New scene ID:', data.scene_id);
            
            // ÌòÑÏû¨ Ïî¨Ïù¥ ÏûàÏúºÎ©¥ ÏïÑÏõÉÎ™®ÏÖò Ï†ÅÏö©
            if (currentScene) {
                // Î™®Îì† Ïù∏Î™®ÏÖòÏù¥ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
                const allElements = container.querySelectorAll('.overlay-object');
                const allCompleted = Array.from(allElements).every(el => el.dataset.inMotionCompleted === 'true');
                
                if (!allCompleted) {
                    console.log('‚è≥ Waiting for all in-motions to complete...');
                    return;
                }

                // ÏïÑÏõÉÎ™®ÏÖò Ï†ÅÏö© Î∞è ÏôÑÎ£å ÎåÄÍ∏∞
                await motionManager.waitForAllOutMotions();
            }
            
            // ÌîÑÎ¶¨Î°úÎî©Îêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ API Ìò∏Ï∂ú
            let newScene;
            if (preloadCache && preloadCache.scenes) {
                const cachedScene = preloadCache.scenes.find(s => s.id === data.scene_id);
                if (cachedScene) {
                    console.log('üíæ Using preloaded scene data:', cachedScene);
                    newScene = cachedScene;
                }
            }
            
            if (!newScene) {
                // ÌîÑÎ¶¨Î°úÎî©Îêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ API Ìò∏Ï∂ú
                try {
                    console.log('üåê Loading scene from API:', data.scene_id);
                    const response = await fetch(`/api/scenes/${data.scene_id}`);
                    newScene = await response.json();
                    console.log('üì• New scene loaded from API:', newScene);
                } catch (error) {
                    console.error('‚ùå Error loading new scene:', error);
                    return;
                }
            }
            
            // ÏÉà Ïî¨ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
            currentScene = newScene;
            motionManager.updateScene(newScene, false); // skipInMotion = false (Ïù∏Î™®ÏÖò Ï†ÅÏö©)
            
            console.log('‚úÖ New scene applied successfully');
        });

        socket.on('scene_out', async function(data) {
            console.log('üé≠ Scene out event received:', data);
            console.log('Current scene before out motion:', currentScene);
            console.log('MotionManager current scene:', motionManager.currentScene);
            
            // ÏïÑÏõÉÎ™®ÏÖò Ï†ÅÏö© Î∞è ÏôÑÎ£å ÎåÄÍ∏∞
            await motionManager.waitForAllOutMotions();
            
            // ÏïÑÏõÉÎ™®ÏÖò ÏôÑÎ£å ÌõÑ Í∞ùÏ≤¥Îì§ Ïà®Í∏∞Í∏∞
            const elements = container.querySelectorAll('.overlay-object');
            elements.forEach(element => {
                element.style.display = 'none';
            });

            // ÎçîÎØ∏ Ïî¨ÏúºÎ°ú ÍµêÏ≤¥
            console.log('üîÑ Loading dummy scene...');
            try {
                const response = await fetch('/api/dummy-scene');
                const dummyScene = await response.json();
                console.log('üì• Dummy scene loaded:', dummyScene);
                
                // ÎçîÎØ∏ Ïî¨ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ (Ïù∏Î™®ÏÖò Ïä§ÌÇµ)
                currentScene = dummyScene;
                motionManager.updateScene(dummyScene, true); // skipInMotion = true
                
                console.log('‚úÖ Dummy scene applied - no objects to display');
            } catch (error) {
                console.error('‚ùå Error loading dummy scene:', error);
            }
        });

        // Í∞ùÏ≤¥ ÏÉùÏÑ± Ìï®Ïàò
        function createObjectElement(obj) {
            const element = document.createElement('div');
            element.className = 'overlay-object';
            element.id = `obj-${obj.id}`;
            element.setAttribute('data-object-id', obj.id);
            
            // Í∏∞Î≥∏ Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
            element.style.position = 'absolute';
            element.style.left = '0px';
            element.style.top = '0px';
            
            // Í∞ùÏ≤¥ ÌÉÄÏûÖÏóê Îî∞Î•∏ Ï≤òÎ¶¨
            switch (obj.type) {
                case 'text': {
                    console.log('Text object properties:', obj.properties);
                    
                    // ÌÖçÏä§Ìä∏ Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
                    const textContainer = document.createElement('div');
                    textContainer.style.display = 'flex';
                    textContainer.style.alignItems = 'center';
                    textContainer.style.justifyContent = obj.properties.textAlign === 'left' ? 'flex-start' : 
                                                       obj.properties.textAlign === 'right' ? 'flex-end' : 'center';
                    textContainer.style.width = '100%';
                    textContainer.style.height = '100%';
                    textContainer.style.boxSizing = 'border-box';

                    // SVG ÏÉùÏÑ±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.overflow = 'visible';

                    // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎòêÎäî Îã®ÏÉâ Ï†ÅÏö©
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        const { angle = 0, stops = [] } = obj.properties.gradient;
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ID ÏÉùÏÑ±
                        const gradientId = `text-gradient-${obj.id}`;
                        
                        // linearGradient ÏöîÏÜå ÏÉùÏÑ±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Í∞ÅÎèÑ Í≥ÑÏÇ∞ (0ÎèÑÎäî ÏôºÏ™ΩÏóêÏÑú Ïò§Î•∏Ï™Ω)
                        const radians = (angle * Math.PI / 180);
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä§ÌÜ± Ï∂îÍ∞Ä
                        stops.forEach(stop => {
                            const stopEl = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopEl.setAttribute('offset', `${stop.position * 100}%`);
                            stopEl.setAttribute('stop-color', stop.color);
                            stopEl.setAttribute('stop-opacity', stop.opacity ?? 1);
                            gradient.appendChild(stopEl);
                        });
                        
                        // defsÏóê Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ï∂îÍ∞Ä
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        fillValue = obj.properties.color || '#FFFFFF';
                    }

                    // ÌÖçÏä§Ìä∏ ÏöîÏÜå ÏÉùÏÑ±
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = obj.properties.content || '';
                    text.setAttribute('x', '50%');
                    text.setAttribute('y', '50%');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('text-anchor', obj.properties.textAlign === 'left' ? 'start' : 
                                                   obj.properties.textAlign === 'right' ? 'end' : 'middle');
                    text.setAttribute('font-family', obj.properties.fontFamily || 'Arial');
                    text.setAttribute('font-size', `${obj.properties.fontSize || 24}px`);
                    text.setAttribute('font-weight', obj.properties.fontWeight || 'normal');
                    text.setAttribute('fill', fillValue);
                    text.setAttribute('fill-opacity', obj.properties.fillType === 'gradient' ? 1 : (obj.properties.opacity ?? 1));

                    // ÌÖçÏä§Ìä∏ ÌÖåÎëêÎ¶¨
                    if (obj.properties.useTextBorder) {
                        text.setAttribute('stroke', obj.properties.textBorderColor || '#000000');
                        text.setAttribute('stroke-width', obj.properties.textBorderWidth || 1);
                    }

                    // ÌÖçÏä§Ìä∏ Í∑∏Î¶ºÏûê
                    if (obj.properties.useTextShadow) {
                        const shadowX = obj.properties.textShadowOffsetX || 0;
                        const shadowY = obj.properties.textShadowOffsetY || 0;
                        const shadowBlur = obj.properties.textShadowBlur || 0;
                        const shadowColor = obj.properties.textShadowColor || '#000000';
                        text.style.filter = `drop-shadow(${shadowX}px ${shadowY}px ${shadowBlur}px ${shadowColor})`;
                    }

                    svg.appendChild(text);
                    textContainer.appendChild(svg);
                    element.appendChild(textContainer);
                    break;
                }

                case 'image':
                    const img = document.createElement('img');
                    img.src = obj.properties.src || '';
                    img.style.width = obj.properties.width ? obj.properties.width + 'px' : '100%';
                    img.style.height = obj.properties.height ? obj.properties.height + 'px' : '100%';
                    img.style.objectFit = 'contain';
                    img.style.display = 'block';
                    img.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    element.style.setProperty('--target-opacity', obj.properties.opacity !== undefined ? obj.properties.opacity : 1);
                    element.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    element.appendChild(img);
                    break;
                    
                case 'shape': {
                    const width = obj.properties.width || 100;
                    const height = obj.properties.height || 100;
                    const opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
                    const cornerRadius = obj.properties.cornerRadius || {
                        topLeft: 0,
                        topRight: 0,
                        bottomLeft: 0,
                        bottomRight: 0
                    };

                    // SVG Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', width);
                    svg.setAttribute('height', height);
                    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    svg.style.display = 'block';
                    svg.style.width = '100%';
                    svg.style.height = '100%';

                    // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎòêÎäî Îã®ÏÉâ Ï±ÑÏö∞Í∏∞ ÏÑ§Ï†ï
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ID ÏÉùÏÑ±
                        const gradientId = `gradient-${obj.id}`;
                        
                        // linearGradient ÏöîÏÜå ÏÉùÏÑ±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Í∞ÅÎèÑ ÏÑ§Ï†ï (0ÎèÑÎäî ÏôºÏ™ΩÏóêÏÑú Ïò§Î•∏Ï™Ω)
                        const angle = obj.properties.gradient.angle || 0;
                        const radians = angle * (Math.PI / 180);
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä§ÌÜ± Ï∂îÍ∞Ä
                        const stops = obj.properties.gradient.stops || [
                            {color: '#FF0000', opacity: 1, position: 0},
                            {color: '#0000FF', opacity: 1, position: 1}
                        ];
                        
                        stops.forEach(stop => {
                            const stopElement = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopElement.setAttribute('offset', `${stop.position * 100}%`);
                            stopElement.setAttribute('stop-color', stop.color);
                            stopElement.setAttribute('stop-opacity', stop.opacity);
                            gradient.appendChild(stopElement);
                        });
                        
                        // defsÏóê Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ï∂îÍ∞Ä
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        // Îã®ÏÉâ Ï±ÑÏö∞Í∏∞
                        fillValue = obj.properties.color || '#FF0000';
                    }

                    let shapeElement;
                    if (obj.properties.shapeType === 'triangle') {
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        shapeElement.setAttribute('points', `${width/2},0 0,${height} ${width},${height}`);
                    } else if (obj.properties.shapeType === 'circle' || obj.properties.shapeType === 'ellipse') {
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                        shapeElement.setAttribute('cx', width/2);
                        shapeElement.setAttribute('cy', height/2);
                        shapeElement.setAttribute('rx', width/2);
                        shapeElement.setAttribute('ry', height/2);
                    } else {
                        // ÏÇ¨Í∞ÅÌòï (box)
                        shapeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        
                        // SVG path ÏÉùÏÑ±
                        const path = [
                            `M${cornerRadius.topLeft},0`, // ÏãúÏûëÏ†ê (Ï¢åÏÉÅÎã®)
                            `h${width - cornerRadius.topLeft - cornerRadius.topRight}`, // ÏÉÅÎã® Í∞ÄÎ°úÏÑ†
                            `q${cornerRadius.topRight},0 ${cornerRadius.topRight},${cornerRadius.topRight}`, // Ïö∞ÏÉÅÎã® Î™®ÏÑúÎ¶¨
                            `v${height - cornerRadius.topRight - cornerRadius.bottomRight}`, // Ïö∞Ï∏° ÏÑ∏Î°úÏÑ†
                            `q0,${cornerRadius.bottomRight} -${cornerRadius.bottomRight},${cornerRadius.bottomRight}`, // Ïö∞ÌïòÎã® Î™®ÏÑúÎ¶¨
                            `h-${width - cornerRadius.bottomRight - cornerRadius.bottomLeft}`, // ÌïòÎã® Í∞ÄÎ°úÏÑ†
                            `q-${cornerRadius.bottomLeft},0 -${cornerRadius.bottomLeft},-${cornerRadius.bottomLeft}`, // Ï¢åÌïòÎã® Î™®ÏÑúÎ¶¨
                            `v-${height - cornerRadius.bottomLeft - cornerRadius.topLeft}`, // Ï¢åÏ∏° ÏÑ∏Î°úÏÑ†
                            `q0,-${cornerRadius.topLeft} ${cornerRadius.topLeft},-${cornerRadius.topLeft}`, // Ï¢åÏÉÅÎã® Î™®ÏÑúÎ¶¨
                            'z' // Îã´Í∏∞
                        ].join(' ');
                        
                        shapeElement.setAttribute('d', path);
                    }

                    shapeElement.setAttribute('fill', fillValue);
                    shapeElement.setAttribute('opacity', opacity);

                    if (obj.properties.useShapeBorder) {
                        shapeElement.setAttribute('stroke', obj.properties.shapeBorderColor || '#FFFFFF');
                        shapeElement.setAttribute('stroke-width', obj.properties.shapeBorderWidth || 1);
                    }

                    if (obj.properties.useShapeShadow) {
                        shapeElement.style.filter = `drop-shadow(${obj.properties.shapeShadowOffsetX||0}px ${obj.properties.shapeShadowOffsetY||0}px ${obj.properties.shapeShadowBlur||0}px ${obj.properties.shapeShadowColor||'#000'})`;
                    }

                    svg.appendChild(shapeElement);
                    element.appendChild(svg);
                    break;
                }

                case 'timer': {
                    console.log('Timer object properties:', obj.properties);
                    
                    // ÌÉÄÏù¥Î®∏ Ïª®ÌÖåÏù¥ÎÑà ÏÉùÏÑ±
                    const timerContainer = document.createElement('div');
                    timerContainer.style.display = 'flex';
                    timerContainer.style.alignItems = 'center';
                    timerContainer.style.justifyContent = obj.properties.textAlign === 'left' ? 'flex-start' : 
                                                        obj.properties.textAlign === 'right' ? 'flex-end' : 'center';
                    timerContainer.style.width = '100%';
                    timerContainer.style.height = '100%';
                    timerContainer.style.boxSizing = 'border-box';

                    // SVG ÏÉùÏÑ±
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.style.width = '100%';
                    svg.style.height = '100%';
                    svg.style.overflow = 'visible';

                    // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÎòêÎäî Îã®ÏÉâ Ï†ÅÏö©
                    let fillValue;
                    if (obj.properties.fillType === 'gradient' && obj.properties.gradient) {
                        const { angle = 0, stops = [] } = obj.properties.gradient;
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò ID ÏÉùÏÑ±
                        const gradientId = `timer-gradient-${obj.id}`;
                        
                        // linearGradient ÏöîÏÜå ÏÉùÏÑ±
                        const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                        gradient.setAttribute('id', gradientId);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Í∞ÅÎèÑ Í≥ÑÏÇ∞ (0ÎèÑÎäî ÏôºÏ™ΩÏóêÏÑú Ïò§Î•∏Ï™Ω)
                        const radians = angle * Math.PI / 180;
                        const x1 = 50 - Math.cos(radians) * 50;
                        const y1 = 50 - Math.sin(radians) * 50;
                        const x2 = 50 + Math.cos(radians) * 50;
                        const y2 = 50 + Math.sin(radians) * 50;
                        
                        gradient.setAttribute('x1', `${x1}%`);
                        gradient.setAttribute('y1', `${y1}%`);
                        gradient.setAttribute('x2', `${x2}%`);
                        gradient.setAttribute('y2', `${y2}%`);
                        
                        // Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ïä§ÌÜ± Ï∂îÍ∞Ä
                        stops.forEach(stop => {
                            const stopEl = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                            stopEl.setAttribute('offset', `${stop.position * 100}%`);
                            stopEl.setAttribute('stop-color', stop.color);
                            stopEl.setAttribute('stop-opacity', stop.opacity ?? 1);
                            gradient.appendChild(stopEl);
                        });
                        
                        // defsÏóê Í∑∏ÎùºÎç∞Ïù¥ÏÖò Ï∂îÍ∞Ä
                        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        defs.appendChild(gradient);
                        svg.appendChild(defs);
                        
                        fillValue = `url(#${gradientId})`;
                    } else {
                        fillValue = obj.properties.color || '#FFFFFF';
                    }

                    // ÌÉÄÏù¥Î®∏ ÌÖçÏä§Ìä∏ ÏöîÏÜå ÏÉùÏÑ±
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.textContent = obj.properties.content || '00:00';
                    text.setAttribute('x', '50%');
                    text.setAttribute('y', '50%');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('text-anchor', obj.properties.textAlign === 'left' ? 'start' : 
                                                   obj.properties.textAlign === 'right' ? 'end' : 'middle');
                    text.setAttribute('font-family', obj.properties.fontFamily || 'Arial');
                    text.setAttribute('font-size', `${obj.properties.fontSize || 48}px`);
                    text.setAttribute('font-weight', obj.properties.fontWeight || 'bold');
                    text.setAttribute('fill', fillValue);
                    text.setAttribute('fill-opacity', obj.properties.fillType === 'gradient' ? 1 : (obj.properties.opacity ?? 1));

                    svg.appendChild(text);
                    timerContainer.appendChild(svg);
                    element.appendChild(timerContainer);
                    break;
                }

                case 'sequence':
                    // ÏãúÌÄÄÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
                    const canvas = document.createElement('canvas');
                    canvas.width = obj.properties.width || obj.properties.frameWidth || 100;
                    canvas.height = obj.properties.height || obj.properties.frameHeight || 100;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.display = 'block';
                    
                    // Ìà¨Î™ÖÎèÑ ÏßÄÏõêÏùÑ ÏúÑÌïú Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // ÏãúÌÄÄÏä§ Ïï†ÎãàÎ©îÏù¥ÏÖò Î≥ÄÏàò
                    let currentFrame = obj.properties.currentFrame || 0;
                    let frameCount = obj.properties.frameCount || 1;
                    let frameWidth = obj.properties.frameWidth || 100;
                    let frameHeight = obj.properties.frameHeight || 100;
                    let fps = obj.properties.fps || 24;
                    let spriteUrl = obj.properties.spriteUrl || '';
                    let spriteImage = null;
                    let animationInterval = null;
                    
                    // Ïä§ÌîÑÎùºÏù¥Ìä∏ Ïù¥ÎØ∏ÏßÄ Î°úÎìú
                    if (spriteUrl) {
                        const img = new Image();
                        img.crossOrigin = 'anonymous'; // CORS ÏÑ§Ï†ï
                        img.onload = function() {
                            spriteImage = img;
                            drawFrame();
                        };
                        img.onerror = function() {
                            console.error('Failed to load sprite image:', spriteUrl);
                        };
                        img.src = spriteUrl;
                    }
                    
                    // ÌîÑÎ†àÏûÑ Í∑∏Î¶¨Í∏∞ Ìï®Ïàò
                    function drawFrame() {
                        if (!spriteImage || !ctx) return;
                        
                        // Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶¨Ïñ¥ (Ìà¨Î™ÖÌïòÍ≤å)
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // ÌòÑÏû¨ ÌîÑÎ†àÏûÑ Í∑∏Î¶¨Í∏∞ (Ìà¨Î™ÖÎèÑ Ïú†ÏßÄ)
                        ctx.drawImage(
                            spriteImage,
                            0, frameHeight * currentFrame, // ÏÜåÏä§ x, y
                            frameWidth, frameHeight,        // ÏÜåÏä§ width, height
                            0, 0,                          // ÎåÄÏÉÅ x, y
                            canvas.width, canvas.height     // ÎåÄÏÉÅ width, height
                        );
                    }
                    
                    // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
                    function startAnimation() {
                        if (animationInterval) return;
                        animationInterval = setInterval(() => {
                            if (obj.properties.loop === false) {
                                // ÎßàÏßÄÎßâ ÌîÑÎ†àÏûÑÏù¥Î©¥ Î©àÏ∂§
                                if (currentFrame >= frameCount - 1) {
                                    stopAnimation();
                                    return;
                                }
                                currentFrame++;
                            } else {
                                // Î£®ÌîÑÏùº ÎïåÎßå Î∞òÎ≥µ
                                currentFrame = (currentFrame + 1) % frameCount;
                            }
                            drawFrame();
                        }, 1000 / fps);
                    }
                    
                    // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ïÏßÄ
                    function stopAnimation() {
                        if (animationInterval) {
                            clearInterval(animationInterval);
                            animationInterval = null;
                        }
                    }
                    
                    // Ïï†ÎãàÎ©îÏù¥ÏÖò Î¶¨ÏÖã
                    function resetAnimation() {
                        stopAnimation();
                        currentFrame = 0;
                        drawFrame();
                    }
                    
                    // ÏãúÌÄÄÏä§ Ïª®Ìä∏Î°§ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
                    socket.on('sequence_control', (data) => {
                        if (data.sequence_id === obj.id) {
                            switch (data.action) {
                                case 'play':
                                    startAnimation();
                                    break;
                                case 'pause':
                                    stopAnimation();
                                    break;
                                case 'reset':
                                    resetAnimation();
                                    break;
                                case 'setFrame':
                                    currentFrame = Math.max(0, Math.min(data.frame, frameCount - 1));
                                    drawFrame();
                                    break;
                            }
                        }
                    });
                    
                    // ÏûêÎèô Ïû¨ÏÉù ÏÑ§Ï†ï
                    if (obj.properties.autoPlay !== false) {
                        startAnimation();
                    }
                    
                    element.appendChild(canvas);
                    break;
            }
            
            // ÏúÑÏπò Î∞è ÌÅ¨Í∏∞ ÏÑ§Ï†ï
            element.style.left = `${obj.properties.x || 0}px`;
            element.style.top = `${obj.properties.y || 0}px`;
            element.style.width = `${obj.properties.width || 100}px`;
            element.style.height = `${obj.properties.height || 100}px`;
            
            // Ìà¨Î™ÖÎèÑ ÏÑ§Ï†ï
            element.style.opacity = obj.properties.opacity !== undefined ? obj.properties.opacity : 1;
            
            // ÌöåÏ†Ñ ÏÑ§Ï†ï
            if (obj.properties.rotation !== undefined && obj.properties.rotation !== null) {
                console.log(`Applying rotation to object ${obj.id}: ${obj.properties.rotation}deg`);
                // transform-originÏùÑ Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï
                element.style.transformOrigin = 'center center';
                // Í∏∞Ï°¥ transformÏù¥ ÏûàÏúºÎ©¥ Î≥ëÌï©, ÏóÜÏúºÎ©¥ ÏÉàÎ°ú ÏÉùÏÑ±
                const existingTransform = element.style.transform || '';
                const rotationTransform = `rotate(${obj.properties.rotation}deg)`;
                const finalTransform = existingTransform ? `${existingTransform} ${rotationTransform}` : rotationTransform;
                element.style.transform = finalTransform;
                // ÌöåÏ†ÑÏù¥ ÌôïÏã§Ìûà Ï†ÅÏö©ÎêòÎèÑÎ°ù Í∞ïÏ†ú ÏÑ§Ï†ï
                element.style.setProperty('transform', finalTransform, 'important');
                // Ï∂îÍ∞ÄÎ°ú CSS ÌÅ¥ÎûòÏä§Î•º ÌÜµÌïú ÌöåÏ†Ñ Ï†ÅÏö©
                element.classList.add('rotated-object');
                element.setAttribute('data-rotation', obj.properties.rotation);
                console.log(`Final transform for object ${obj.id}:`, finalTransform);
                console.log(`Applied transform style:`, element.style.transform);
            }
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ ÎÅùÎÇú ÌõÑ opacityÎ•º --target-opacityÎ°ú Í∞ïÏ†ú ÎçÆÏñ¥Ïì∞Í∏∞
            element.addEventListener('animationend', function() {
                const targetOpacity = element.style.getPropertyValue('--target-opacity') || 1;
                element.style.opacity = targetOpacity;
            });
            
            return element;
        }

        function applyObjectStyles(element, object) {
            const properties = object.properties || {};
            element.style.left = `${properties.x || 0}px`;
            element.style.top = `${properties.y || 0}px`;
            element.style.width = `${properties.width || 200}px`;
            element.style.height = `${properties.height || 100}px`;
            element.style.opacity = properties.opacity ?? 1;

            // Î™®ÏÑúÎ¶¨ Îë•Í∏ÄÍ∏∞ Ï≤òÎ¶¨
            if (properties.cornerRadius) {
                element.style.borderTopLeftRadius = `${properties.cornerRadius.topLeft || 0}px`;
                element.style.borderTopRightRadius = `${properties.cornerRadius.topRight || 0}px`;
                element.style.borderBottomLeftRadius = `${properties.cornerRadius.bottomLeft || 0}px`;
                element.style.borderBottomRightRadius = `${properties.cornerRadius.bottomRight || 0}px`;
            }

            // ÌöåÏ†Ñ Ï≤òÎ¶¨
            if (properties.rotation) {
                element.style.transform = `rotate(${properties.rotation}deg)`;
            }
        }
    </script>
</body>
</html> 